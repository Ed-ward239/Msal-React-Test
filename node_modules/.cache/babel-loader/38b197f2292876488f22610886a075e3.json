{"ast":null,"code":"/*! @azure/msal-common v13.0.0 2023-05-01 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { RegionDiscoverySources, ResponseCodes, Constants } from '../utils/Constants.js';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar RegionDiscovery =\n/** @class */\nfunction () {\n  function RegionDiscovery(networkInterface, performanceClient, correlationId) {\n    this.networkInterface = networkInterface;\n    this.performanceClient = performanceClient;\n    this.correlationId = correlationId;\n  }\n  /**\r\n   * Detect the region from the application's environment.\r\n   *\r\n   * @returns Promise<string | null>\r\n   */\n\n\n  RegionDiscovery.prototype.detectRegion = function (environmentRegion, regionDiscoveryMetadata) {\n    var _a, _b, _c, _d;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var autodetectedRegionName, options, localIMDSVersionResponse, currentIMDSVersion, currentIMDSVersionResponse;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);\n            autodetectedRegionName = environmentRegion;\n            if (!!autodetectedRegionName) return [3\n            /*break*/\n            , 8];\n            options = RegionDiscovery.IMDS_OPTIONS;\n            _e.label = 1;\n\n          case 1:\n            _e.trys.push([1, 6,, 7]);\n\n            (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\n            return [4\n            /*yield*/\n            , this.getRegionFromIMDS(Constants.IMDS_VERSION, options)];\n\n          case 2:\n            localIMDSVersionResponse = _e.sent();\n\n            if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n              autodetectedRegionName = localIMDSVersionResponse.body;\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n            }\n\n            if (!(localIMDSVersionResponse.status === ResponseCodes.httpBadRequest)) return [3\n            /*break*/\n            , 5];\n            (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);\n            return [4\n            /*yield*/\n            , this.getCurrentVersion(options)];\n\n          case 3:\n            currentIMDSVersion = _e.sent();\n\n            if (!currentIMDSVersion) {\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n              return [2\n              /*return*/\n              , null];\n            }\n\n            (_d = this.performanceClient) === null || _d === void 0 ? void 0 : _d.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\n            return [4\n            /*yield*/\n            , this.getRegionFromIMDS(currentIMDSVersion, options)];\n\n          case 4:\n            currentIMDSVersionResponse = _e.sent();\n\n            if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n              autodetectedRegionName = currentIMDSVersionResponse.body;\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n            }\n\n            _e.label = 5;\n\n          case 5:\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            _e.sent();\n\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n            return [2\n            /*return*/\n            , null];\n\n          case 7:\n            return [3\n            /*break*/\n            , 9];\n\n          case 8:\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;\n            _e.label = 9;\n\n          case 9:\n            // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\n            if (!autodetectedRegionName) {\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n            }\n\n            return [2\n            /*return*/\n            , autodetectedRegionName || null];\n        }\n      });\n    });\n  };\n  /**\r\n   * Make the call to the IMDS endpoint\r\n   *\r\n   * @param imdsEndpointUrl\r\n   * @returns Promise<NetworkResponse<string>>\r\n   */\n\n\n  RegionDiscovery.prototype.getRegionFromIMDS = function (version, options) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_b) {\n        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\n        return [2\n        /*return*/\n        , this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + \"?api-version=\" + version + \"&format=text\", options, Constants.IMDS_TIMEOUT)];\n      });\n    });\n  };\n  /**\r\n   * Get the most recent version of the IMDS endpoint available\r\n   *\r\n   * @returns Promise<string | null>\r\n   */\n\n\n  RegionDiscovery.prototype.getCurrentVersion = function (options) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var response;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + \"?format=json\", options)];\n\n          case 2:\n            response = _b.sent(); // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\n\n            if (response.status === ResponseCodes.httpBadRequest && response.body && response.body[\"newest-versions\"] && response.body[\"newest-versions\"].length > 0) {\n              return [2\n              /*return*/\n              , response.body[\"newest-versions\"][0]];\n            }\n\n            return [2\n            /*return*/\n            , null];\n\n          case 3:\n            _b.sent();\n\n            return [2\n            /*return*/\n            , null];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // Options for the IMDS endpoint request\n\n\n  RegionDiscovery.IMDS_OPTIONS = {\n    headers: {\n      Metadata: \"true\"\n    }\n  };\n  return RegionDiscovery;\n}();\n\nexport { RegionDiscovery };","map":{"version":3,"mappings":"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","names":["networkInterface","performanceClient","correlationId","RegionDiscovery","environmentRegion","regionDiscoveryMetadata","_a","addQueueMeasurement","PerformanceEvents","RegionDiscoveryDetectRegion","autodetectedRegionName","options","IMDS_OPTIONS","_b","setPreQueueTime","RegionDiscoveryGetRegionFromIMDS","getRegionFromIMDS","Constants","IMDS_VERSION","localIMDSVersionResponse","_e","status","ResponseCodes","httpSuccess","body","region_source","RegionDiscoverySources","IMDS","httpBadRequest","_c","RegionDiscoveryGetCurrentVersion","getCurrentVersion","currentIMDSVersion","FAILED_AUTO_DETECTION","_d","currentIMDSVersionResponse","ENVIRONMENT_VARIABLE","version","sendGetRequestAsync","IMDS_ENDPOINT","IMDS_TIMEOUT","response","length","headers","Metadata"],"sources":["/Users/edwardlee/Downloads/msal-react-demo/node_modules/@azure/msal-common/src/authority/RegionDiscovery.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { INetworkModule } from \"../network/INetworkModule\";\nimport { NetworkResponse } from \"../network/NetworkManager\";\nimport { IMDSBadResponse } from \"../response/IMDSBadResponse\";\nimport { Constants, RegionDiscoverySources, ResponseCodes } from \"../utils/Constants\";\nimport { RegionDiscoveryMetadata } from \"./RegionDiscoveryMetadata\";\nimport { ImdsOptions } from \"./ImdsOptions\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent\";\n\nexport class RegionDiscovery {\n    // Network interface to make requests with.\n    protected networkInterface: INetworkModule;\n    // Performance client\n    protected performanceClient: IPerformanceClient | undefined;\n    // CorrelationId\n    protected correlationId: string | undefined;\n    // Options for the IMDS endpoint request\n    protected static IMDS_OPTIONS: ImdsOptions = {\n        headers: {\n            Metadata: \"true\",\n        },\n    };\n\n    constructor(networkInterface: INetworkModule, performanceClient?: IPerformanceClient, correlationId?: string) {\n        this.networkInterface = networkInterface;\n        this.performanceClient = performanceClient;\n        this.correlationId = correlationId;\n    }\n\n    /**\n     * Detect the region from the application's environment.\n     * \n     * @returns Promise<string | null>\n     */\n    public async detectRegion(environmentRegion: string | undefined, regionDiscoveryMetadata: RegionDiscoveryMetadata): Promise<string | null> {\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);\n        \n        // Initialize auto detected region with the region from the envrionment \n        let autodetectedRegionName = environmentRegion;\n\n        // Check if a region was detected from the environment, if not, attempt to get the region from IMDS \n        if (!autodetectedRegionName) {\n            const options = RegionDiscovery.IMDS_OPTIONS;\n\n            try {\n                this.performanceClient?.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\n                const localIMDSVersionResponse = await this.getRegionFromIMDS(Constants.IMDS_VERSION, options);\n                if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n                    autodetectedRegionName = localIMDSVersionResponse.body;\n                    regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n                } \n                \n                // If the response using the local IMDS version failed, try to fetch the current version of IMDS and retry. \n                if (localIMDSVersionResponse.status === ResponseCodes.httpBadRequest) {\n                    this.performanceClient?.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);\n                    const currentIMDSVersion = await this.getCurrentVersion(options);\n                    if (!currentIMDSVersion) {\n                        regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n                        return null;\n                    }\n\n                    this.performanceClient?.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\n                    const currentIMDSVersionResponse = await this.getRegionFromIMDS(currentIMDSVersion, options);\n                    if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n                        autodetectedRegionName = currentIMDSVersionResponse.body;\n                        regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n                    }\n                }\n            } catch(e) {\n                regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n                return null;\n            } \n        } else {\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;\n        }\n\n        // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\n        if (!autodetectedRegionName) {\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n        }\n\n        return autodetectedRegionName || null;\n    }\n\n    /**\n     * Make the call to the IMDS endpoint\n     * \n     * @param imdsEndpointUrl\n     * @returns Promise<NetworkResponse<string>>\n     */\n    private async getRegionFromIMDS(version: string, options: ImdsOptions): Promise<NetworkResponse<string>> {\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\n        return this.networkInterface.sendGetRequestAsync<string>(`${Constants.IMDS_ENDPOINT}?api-version=${version}&format=text`, options, Constants.IMDS_TIMEOUT);\n    }\n\n    /**\n     * Get the most recent version of the IMDS endpoint available\n     *  \n     * @returns Promise<string | null>\n     */\n    private async getCurrentVersion(options: ImdsOptions): Promise<string | null> {\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);\n        try {\n            const response = await this.networkInterface.sendGetRequestAsync<IMDSBadResponse>(`${Constants.IMDS_ENDPOINT}?format=json`, options);\n\n            // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\n            if (response.status === ResponseCodes.httpBadRequest && response.body && response.body[\"newest-versions\"] && response.body[\"newest-versions\"].length > 0) {\n                return response.body[\"newest-versions\"][0];\n            }\n\n            return null;\n        } catch (e) {\n            return null;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}