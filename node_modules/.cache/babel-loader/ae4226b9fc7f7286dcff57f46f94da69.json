{"ast":null,"code":"/*! @azure/msal-common v13.0.0 2023-05-01 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { buildClientInfo } from '../account/ClientInfo.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { ServerError } from '../error/ServerError.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from '../cache/entities/AccountEntity.js';\nimport { AuthorityType } from '../authority/AuthorityType.js';\nimport { IdTokenEntity } from '../cache/entities/IdTokenEntity.js';\nimport { AccessTokenEntity } from '../cache/entities/AccessTokenEntity.js';\nimport { RefreshTokenEntity } from '../cache/entities/RefreshTokenEntity.js';\nimport { InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.js';\nimport { CacheRecord } from '../cache/entities/CacheRecord.js';\nimport { ProtocolUtils } from '../utils/ProtocolUtils.js';\nimport { Constants, AuthenticationScheme, THE_FAMILY_ID } from '../utils/Constants.js';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.js';\nimport { AppMetadataEntity } from '../cache/entities/AppMetadataEntity.js';\nimport { TokenCacheContext } from '../cache/persistence/TokenCacheContext.js';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Class that handles response parsing.\r\n */\n\nvar ResponseHandler =\n/** @class */\nfunction () {\n  function ResponseHandler(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {\n    this.clientId = clientId;\n    this.cacheStorage = cacheStorage;\n    this.cryptoObj = cryptoObj;\n    this.logger = logger;\n    this.serializableCache = serializableCache;\n    this.persistencePlugin = persistencePlugin;\n    this.performanceClient = performanceClient;\n  }\n  /**\r\n   * Function which validates server authorization code response.\r\n   * @param serverResponseHash\r\n   * @param cachedState\r\n   * @param cryptoObj\r\n   */\n\n\n  ResponseHandler.prototype.validateServerAuthorizationCodeResponse = function (serverResponseHash, cachedState, cryptoObj) {\n    if (!serverResponseHash.state || !cachedState) {\n      throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError(\"Server State\") : ClientAuthError.createStateNotFoundError(\"Cached State\");\n    }\n\n    if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {\n      throw ClientAuthError.createStateMismatchError();\n    } // Check for error\n\n\n    if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\n      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror, serverResponseHash.timestamp || Constants.EMPTY_STRING, serverResponseHash.trace_id || Constants.EMPTY_STRING, serverResponseHash.correlation_id || Constants.EMPTY_STRING, serverResponseHash.claims || Constants.EMPTY_STRING);\n      }\n\n      throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\n    }\n\n    if (serverResponseHash.client_info) {\n      buildClientInfo(serverResponseHash.client_info, cryptoObj);\n    }\n  };\n  /**\r\n   * Function which validates server authorization token response.\r\n   * @param serverResponse\r\n   */\n\n\n  ResponseHandler.prototype.validateTokenResponse = function (serverResponse) {\n    // Check for error\n    if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\n      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING);\n      }\n\n      var errString = serverResponse.error_codes + \" - [\" + serverResponse.timestamp + \"]: \" + serverResponse.error_description + \" - Correlation ID: \" + serverResponse.correlation_id + \" - Trace ID: \" + serverResponse.trace_id;\n      throw new ServerError(serverResponse.error, errString, serverResponse.suberror);\n    }\n  };\n  /**\r\n   * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n   * @param serverTokenResponse\r\n   * @param authority\r\n   */\n\n\n  ResponseHandler.prototype.handleServerTokenResponse = function (serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var idTokenObj, authTime, requestStateObj, cacheRecord, cacheContext, key, account;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);\n\n            if (serverTokenResponse.id_token) {\n              idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj); // token nonce check (TODO: Add a warning if no nonce is given?)\n\n              if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {\n                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {\n                  throw ClientAuthError.createNonceMismatchError();\n                }\n              } // token max_age check\n\n\n              if (request.maxAge || request.maxAge === 0) {\n                authTime = idTokenObj.claims.auth_time;\n\n                if (!authTime) {\n                  throw ClientAuthError.createAuthTimeNotFoundError();\n                }\n\n                AuthToken.checkMaxAge(authTime, request.maxAge);\n              }\n            } // generate homeAccountId\n\n\n            this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);\n\n            if (!!authCodePayload && !!authCodePayload.state) {\n              requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\n            } // Add keyId from request to serverTokenResponse if defined\n\n\n            serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;\n            cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload);\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1,, 5, 8]);\n\n            if (!(this.persistencePlugin && this.serializableCache)) return [3\n            /*break*/\n            , 3];\n            this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\n            cacheContext = new TokenCacheContext(this.serializableCache, true);\n            return [4\n            /*yield*/\n            , this.persistencePlugin.beforeCacheAccess(cacheContext)];\n\n          case 2:\n            _b.sent();\n\n            _b.label = 3;\n\n          case 3:\n            /*\r\n             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n             * If not present, we should return null, as it's the case that another application called removeAccount in between\r\n             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\r\n             * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\r\n             */\n            if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {\n              key = cacheRecord.account.generateAccountKey();\n              account = this.cacheStorage.getAccount(key);\n\n              if (!account) {\n                this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\n                return [2\n                /*return*/\n                , ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, undefined, serverRequestId)];\n              }\n            }\n\n            return [4\n            /*yield*/\n            , this.cacheStorage.saveCacheRecord(cacheRecord)];\n\n          case 4:\n            _b.sent();\n\n            return [3\n            /*break*/\n            , 8];\n\n          case 5:\n            if (!(this.persistencePlugin && this.serializableCache && cacheContext)) return [3\n            /*break*/\n            , 7];\n            this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\n            return [4\n            /*yield*/\n            , this.persistencePlugin.afterCacheAccess(cacheContext)];\n\n          case 6:\n            _b.sent();\n\n            _b.label = 7;\n\n          case 7:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 8:\n            return [2\n            /*return*/\n            , ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, serverTokenResponse, serverRequestId)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Generates CacheRecord\r\n   * @param serverTokenResponse\r\n   * @param idTokenObj\r\n   * @param authority\r\n   */\n\n\n  ResponseHandler.prototype.generateCacheRecord = function (serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload) {\n    var env = authority.getPreferredCache();\n\n    if (StringUtils.isEmpty(env)) {\n      throw ClientAuthError.createInvalidCacheEnvironmentError();\n    } // IdToken: non AAD scenarios can have empty realm\n\n\n    var cachedIdToken;\n    var cachedAccount;\n\n    if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {\n      cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING);\n      cachedAccount = this.generateAccountEntity(serverTokenResponse, idTokenObj, authority, authCodePayload);\n    } // AccessToken\n\n\n    var cachedAccessToken = null;\n\n    if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {\n      // If scopes not returned in server response, use request scopes\n      var responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);\n      /*\r\n       * Use timestamp calculated before request\r\n       * Server may return timestamps as strings, parse to numbers if so.\r\n       */\n\n      var expiresIn = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\n      var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\n      var refreshIn = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\n      var tokenExpirationSeconds = reqTimestamp + expiresIn;\n      var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\n      var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined; // non AAD scenarios can have empty realm\n\n      cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);\n    } // refreshToken\n\n\n    var cachedRefreshToken = null;\n\n    if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {\n      cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, userAssertionHash);\n    } // appMetadata\n\n\n    var cachedAppMetadata = null;\n\n    if (!StringUtils.isEmpty(serverTokenResponse.foci)) {\n      cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\n    }\n\n    return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\n  };\n  /**\r\n   * Generate Account\r\n   * @param serverTokenResponse\r\n   * @param idToken\r\n   * @param authority\r\n   */\n\n\n  ResponseHandler.prototype.generateAccountEntity = function (serverTokenResponse, idToken, authority, authCodePayload) {\n    var authorityType = authority.authorityType;\n    var cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : Constants.EMPTY_STRING;\n    var msGraphhost = authCodePayload ? authCodePayload.msgraph_host : Constants.EMPTY_STRING; // ADFS does not require client_info in the response\n\n    if (authorityType === AuthorityType.Adfs) {\n      this.logger.verbose(\"Authority type is ADFS, creating ADFS account\");\n      return AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\n    } // This fallback applies to B2C as well as they fall under an AAD account type.\n\n\n    if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === \"AAD\") {\n      throw ClientAuthError.createClientInfoEmptyError();\n    }\n\n    return serverTokenResponse.client_info ? AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost) : AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\n  };\n  /**\r\n   * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n   *\r\n   * Optionally takes a state string that is set as-is in the response.\r\n   *\r\n   * @param cacheRecord\r\n   * @param idTokenObj\r\n   * @param fromTokenCache\r\n   * @param stateString\r\n   */\n\n\n  ResponseHandler.generateAuthenticationResult = function (cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenObj, requestState, serverTokenResponse, requestId) {\n    var _a, _b, _c;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var accessToken, responseScopes, expiresOn, extExpiresOn, familyId, popTokenGenerator, _d, secret, keyId, uid, tid;\n\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            accessToken = Constants.EMPTY_STRING;\n            responseScopes = [];\n            expiresOn = null;\n            familyId = Constants.EMPTY_STRING;\n            if (!cacheRecord.accessToken) return [3\n            /*break*/\n            , 4];\n            if (!(cacheRecord.accessToken.tokenType === AuthenticationScheme.POP)) return [3\n            /*break*/\n            , 2];\n            popTokenGenerator = new PopTokenGenerator(cryptoObj);\n            _d = cacheRecord.accessToken, secret = _d.secret, keyId = _d.keyId;\n\n            if (!keyId) {\n              throw ClientAuthError.createKeyIdMissingError();\n            }\n\n            return [4\n            /*yield*/\n            , popTokenGenerator.signPopToken(secret, keyId, request)];\n\n          case 1:\n            accessToken = _e.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            accessToken = cacheRecord.accessToken.secret;\n            _e.label = 3;\n\n          case 3:\n            responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\n            expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\n            extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\n            _e.label = 4;\n\n          case 4:\n            if (cacheRecord.appMetadata) {\n              familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;\n            }\n\n            uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants.EMPTY_STRING;\n            tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants.EMPTY_STRING; // for hybrid + native bridge enablement, send back the native account Id\n\n            if ((serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid) && !!cacheRecord.account) {\n              cacheRecord.account.nativeAccountId = serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid;\n            }\n\n            return [2\n            /*return*/\n            , {\n              authority: authority.canonicalAuthority,\n              uniqueId: uid,\n              tenantId: tid,\n              scopes: responseScopes,\n              account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,\n              idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,\n              idTokenClaims: idTokenObj ? idTokenObj.claims : {},\n              accessToken: accessToken,\n              fromCache: fromTokenCache,\n              expiresOn: expiresOn,\n              correlationId: request.correlationId,\n              requestId: requestId || Constants.EMPTY_STRING,\n              extExpiresOn: extExpiresOn,\n              familyId: familyId,\n              tokenType: ((_a = cacheRecord.accessToken) === null || _a === void 0 ? void 0 : _a.tokenType) || Constants.EMPTY_STRING,\n              state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\n              cloudGraphHostName: ((_b = cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants.EMPTY_STRING,\n              msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants.EMPTY_STRING,\n              code: serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_code,\n              fromNativeBroker: false\n            }];\n        }\n      });\n    });\n  };\n\n  return ResponseHandler;\n}();\n\nexport { ResponseHandler };","map":{"version":3,"mappings":"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","names":["clientId","cacheStorage","cryptoObj","logger","serializableCache","persistencePlugin","performanceClient","ResponseHandler","serverResponseHash","cachedState","state","ClientAuthError","createStateNotFoundError","decodeURIComponent","createStateMismatchError","error","error_description","suberror","InteractionRequiredAuthError","isInteractionRequiredError","Constants","EMPTY_STRING","timestamp","trace_id","correlation_id","claims","ServerError","client_info","buildClientInfo","validateTokenResponse","serverResponse","errString","error_codes","serverTokenResponse","authority","reqTimestamp","request","authCodePayload","userAssertionHash","handlingRefreshTokenResponse","forceCacheRefreshTokenResponse","serverRequestId","_a","addQueueMeasurement","PerformanceEvents","HandleServerTokenResponse","id_token","idTokenObj","AuthToken","StringUtils","isEmpty","nonce","createNonceMismatchError","maxAge","authTime","auth_time","createAuthTimeNotFoundError","checkMaxAge","homeAccountIdentifier","AccountEntity","generateHomeAccountId","authorityType","requestStateObj","ProtocolUtils","parseRequestState","key_id","sshKid","undefined","cacheRecord","generateCacheRecord","verbose","cacheContext","TokenCacheContext","beforeCacheAccess","_b","account","key","generateAccountKey","getAccount","warning","generateAuthenticationResult","saveCacheRecord","afterCacheAccess","env","getPreferredCache","createInvalidCacheEnvironmentError","cachedIdToken","cachedAccount","IdTokenEntity","createIdTokenEntity","tid","generateAccountEntity","cachedAccessToken","access_token","responseScopes","scope","ScopeSet","fromString","scopes","expiresIn","expires_in","parseInt","extExpiresIn","ext_expires_in","refreshIn","refresh_in","tokenExpirationSeconds","extendedTokenExpirationSeconds","refreshOnSeconds","AccessTokenEntity","createAccessTokenEntity","tenant","printScopes","token_type","requestedClaimsHash","cachedRefreshToken","refresh_token","RefreshTokenEntity","createRefreshTokenEntity","foci","cachedAppMetadata","AppMetadataEntity","createAppMetadataEntity","CacheRecord","idToken","cloudGraphHostName","cloud_graph_host_name","msGraphhost","msgraph_host","AuthorityType","Adfs","createGenericAccount","protocolMode","createClientInfoEmptyError","createAccount","fromTokenCache","requestState","requestId","accessToken","expiresOn","familyId","tokenType","AuthenticationScheme","POP","popTokenGenerator","PopTokenGenerator","_d","secret","keyId","createKeyIdMissingError","signPopToken","_e","target","asArray","Date","Number","extExpiresOn","extendedExpiresOn","appMetadata","THE_FAMILY_ID","uid","oid","sub","spa_accountid","nativeAccountId","canonicalAuthority","uniqueId","tenantId","getAccountInfo","rawToken","idTokenClaims","fromCache","correlationId","userRequestState","msGraphHost","_c","code","spa_code","fromNativeBroker"],"sources":["/Users/edwardlee/Downloads/msal-react-demo/node_modules/@azure/msal-common/src/response/ResponseHandler.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ServerAuthorizationTokenResponse } from \"./ServerAuthorizationTokenResponse\";\nimport { buildClientInfo} from \"../account/ClientInfo\";\nimport { ICrypto } from \"../crypto/ICrypto\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\nimport { StringUtils } from \"../utils/StringUtils\";\nimport { ServerAuthorizationCodeResponse } from \"./ServerAuthorizationCodeResponse\";\nimport { Logger } from \"../logger/Logger\";\nimport { ServerError } from \"../error/ServerError\";\nimport { AuthToken } from \"../account/AuthToken\";\nimport { ScopeSet } from \"../request/ScopeSet\";\nimport { AuthenticationResult } from \"./AuthenticationResult\";\nimport { AccountEntity } from \"../cache/entities/AccountEntity\";\nimport { Authority } from \"../authority/Authority\";\nimport { AuthorityType } from \"../authority/AuthorityType\";\nimport { IdTokenEntity } from \"../cache/entities/IdTokenEntity\";\nimport { AccessTokenEntity } from \"../cache/entities/AccessTokenEntity\";\nimport { RefreshTokenEntity } from \"../cache/entities/RefreshTokenEntity\";\nimport { InteractionRequiredAuthError } from \"../error/InteractionRequiredAuthError\";\nimport { CacheRecord } from \"../cache/entities/CacheRecord\";\nimport { CacheManager } from \"../cache/CacheManager\";\nimport { ProtocolUtils, RequestStateObject } from \"../utils/ProtocolUtils\";\nimport { AuthenticationScheme, Constants, THE_FAMILY_ID } from \"../utils/Constants\";\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator\";\nimport { AppMetadataEntity } from \"../cache/entities/AppMetadataEntity\";\nimport { ICachePlugin } from \"../cache/interface/ICachePlugin\";\nimport { TokenCacheContext } from \"../cache/persistence/TokenCacheContext\";\nimport { ISerializableTokenCache } from \"../cache/interface/ISerializableTokenCache\";\nimport { AuthorizationCodePayload } from \"./AuthorizationCodePayload\";\nimport { BaseAuthRequest } from \"../request/BaseAuthRequest\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent\";\n\n/**\n * Class that handles response parsing.\n */\nexport class ResponseHandler {\n    private clientId: string;\n    private cacheStorage: CacheManager;\n    private cryptoObj: ICrypto;\n    private logger: Logger;\n    private homeAccountIdentifier: string;\n    private serializableCache: ISerializableTokenCache | null;\n    private persistencePlugin: ICachePlugin | null;\n    private performanceClient?: IPerformanceClient;\n\n    constructor(clientId: string, cacheStorage: CacheManager, cryptoObj: ICrypto, logger: Logger, serializableCache: ISerializableTokenCache | null, persistencePlugin: ICachePlugin | null, performanceClient?: IPerformanceClient) {\n        this.clientId = clientId;\n        this.cacheStorage = cacheStorage;\n        this.cryptoObj = cryptoObj;\n        this.logger = logger;\n        this.serializableCache = serializableCache;\n        this.persistencePlugin = persistencePlugin;\n        this.performanceClient = performanceClient;\n    }\n\n    /**\n     * Function which validates server authorization code response.\n     * @param serverResponseHash\n     * @param cachedState\n     * @param cryptoObj\n     */\n    validateServerAuthorizationCodeResponse(serverResponseHash: ServerAuthorizationCodeResponse, cachedState: string, cryptoObj: ICrypto): void {\n\n        if (!serverResponseHash.state || !cachedState) {\n            throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError(\"Server State\") : ClientAuthError.createStateNotFoundError(\"Cached State\");\n        }\n\n        if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {\n            throw ClientAuthError.createStateMismatchError();\n        }\n\n        // Check for error\n        if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\n                throw new InteractionRequiredAuthError(\n                    serverResponseHash.error || Constants.EMPTY_STRING,\n                    serverResponseHash.error_description,\n                    serverResponseHash.suberror,\n                    serverResponseHash.timestamp || Constants.EMPTY_STRING,\n                    serverResponseHash.trace_id || Constants.EMPTY_STRING,\n                    serverResponseHash.correlation_id || Constants.EMPTY_STRING,\n                    serverResponseHash.claims || Constants.EMPTY_STRING,\n                );\n            }\n\n            throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\n        }\n\n        if (serverResponseHash.client_info) {\n            buildClientInfo(serverResponseHash.client_info, cryptoObj);\n        }\n    }\n\n    /**\n     * Function which validates server authorization token response.\n     * @param serverResponse\n     */\n    validateTokenResponse(serverResponse: ServerAuthorizationTokenResponse): void {\n        // Check for error\n        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\n                throw new InteractionRequiredAuthError(\n                    serverResponse.error,\n                    serverResponse.error_description,\n                    serverResponse.suberror,\n                    serverResponse.timestamp || Constants.EMPTY_STRING,\n                    serverResponse.trace_id || Constants.EMPTY_STRING,\n                    serverResponse.correlation_id || Constants.EMPTY_STRING,\n                    serverResponse.claims || Constants.EMPTY_STRING,\n                );\n            }\n\n            const errString = `${serverResponse.error_codes} - [${serverResponse.timestamp}]: ${serverResponse.error_description} - Correlation ID: ${serverResponse.correlation_id} - Trace ID: ${serverResponse.trace_id}`;\n            throw new ServerError(serverResponse.error, errString, serverResponse.suberror);\n        }\n    }\n\n    /**\n     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\n     * @param serverTokenResponse\n     * @param authority\n     */\n    async handleServerTokenResponse(\n        serverTokenResponse: ServerAuthorizationTokenResponse,\n        authority: Authority,\n        reqTimestamp: number,\n        request: BaseAuthRequest,\n        authCodePayload?: AuthorizationCodePayload,\n        userAssertionHash?: string,\n        handlingRefreshTokenResponse?: boolean,\n        forceCacheRefreshTokenResponse?: boolean,\n        serverRequestId?: string): Promise<AuthenticationResult> {\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);\n\n        // create an idToken object (not entity)\n        let idTokenObj: AuthToken | undefined;\n        if (serverTokenResponse.id_token) {\n            idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj);\n\n            // token nonce check (TODO: Add a warning if no nonce is given?)\n            if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {\n                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {\n                    throw ClientAuthError.createNonceMismatchError();\n                }\n            }\n\n            // token max_age check\n            if (request.maxAge || (request.maxAge === 0)) {\n                const authTime = idTokenObj.claims.auth_time;\n                if (!authTime) {\n                    throw ClientAuthError.createAuthTimeNotFoundError();\n                }\n\n                AuthToken.checkMaxAge(authTime, request.maxAge);\n            }\n        }\n\n        // generate homeAccountId\n        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);\n\n        // save the response tokens\n        let requestStateObj: RequestStateObject | undefined;\n        if (!!authCodePayload && !!authCodePayload.state) {\n            requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\n        }\n\n        // Add keyId from request to serverTokenResponse if defined\n        serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;\n\n        const cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload);\n        let cacheContext;\n        try {\n            if (this.persistencePlugin && this.serializableCache) {\n                this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\n                cacheContext = new TokenCacheContext(this.serializableCache, true);\n                await this.persistencePlugin.beforeCacheAccess(cacheContext);\n            }\n            /*\n             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\n             * If not present, we should return null, as it's the case that another application called removeAccount in between\n             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\n             * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\n             */\n            if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {\n                const key = cacheRecord.account.generateAccountKey();\n                const account = this.cacheStorage.getAccount(key);\n                if (!account) {\n                    this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\n                    return ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, undefined, serverRequestId);\n                }\n            }\n            await this.cacheStorage.saveCacheRecord(cacheRecord);\n        } finally {\n            if (this.persistencePlugin && this.serializableCache && cacheContext) {\n                this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\n                await this.persistencePlugin.afterCacheAccess(cacheContext);\n            }\n        }\n        return ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, serverTokenResponse, serverRequestId);\n    }\n\n    /**\n     * Generates CacheRecord\n     * @param serverTokenResponse\n     * @param idTokenObj\n     * @param authority\n     */\n    private generateCacheRecord(serverTokenResponse: ServerAuthorizationTokenResponse, authority: Authority, reqTimestamp: number, request: BaseAuthRequest, idTokenObj?: AuthToken, userAssertionHash?: string, authCodePayload?: AuthorizationCodePayload): CacheRecord {\n        const env = authority.getPreferredCache();\n        if (StringUtils.isEmpty(env)) {\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\n        }\n\n        // IdToken: non AAD scenarios can have empty realm\n        let cachedIdToken: IdTokenEntity | undefined;\n        let cachedAccount: AccountEntity | undefined;\n        if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {\n            cachedIdToken = IdTokenEntity.createIdTokenEntity(\n                this.homeAccountIdentifier,\n                env,\n                serverTokenResponse.id_token || Constants.EMPTY_STRING,\n                this.clientId,\n                idTokenObj.claims.tid || Constants.EMPTY_STRING,\n            );\n\n            cachedAccount = this.generateAccountEntity(\n                serverTokenResponse,\n                idTokenObj,\n                authority,\n                authCodePayload\n            );\n        }\n\n        // AccessToken\n        let cachedAccessToken: AccessTokenEntity | null = null;\n        if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {\n\n            // If scopes not returned in server response, use request scopes\n            const responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);\n\n            /*\n             * Use timestamp calculated before request\n             * Server may return timestamps as strings, parse to numbers if so.\n             */\n            const expiresIn: number = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\n            const extExpiresIn: number = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\n            const refreshIn: number | undefined = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\n            const tokenExpirationSeconds = reqTimestamp + expiresIn;\n            const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\n            const refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;\n\n            // non AAD scenarios can have empty realm\n            cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(\n                this.homeAccountIdentifier,\n                env,\n                serverTokenResponse.access_token || Constants.EMPTY_STRING,\n                this.clientId,\n                idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant,\n                responseScopes.printScopes(),\n                tokenExpirationSeconds,\n                extendedTokenExpirationSeconds,\n                this.cryptoObj,\n                refreshOnSeconds,\n                serverTokenResponse.token_type,\n                userAssertionHash,\n                serverTokenResponse.key_id,\n                request.claims,\n                request.requestedClaimsHash\n            );\n        }\n\n        // refreshToken\n        let cachedRefreshToken: RefreshTokenEntity | null = null;\n        if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {\n            cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(\n                this.homeAccountIdentifier,\n                env,\n                serverTokenResponse.refresh_token || Constants.EMPTY_STRING,\n                this.clientId,\n                serverTokenResponse.foci,\n                userAssertionHash\n            );\n        }\n\n        // appMetadata\n        let cachedAppMetadata: AppMetadataEntity | null = null;\n        if (!StringUtils.isEmpty(serverTokenResponse.foci)) {\n            cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\n        }\n\n        return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\n    }\n\n    /**\n     * Generate Account\n     * @param serverTokenResponse\n     * @param idToken\n     * @param authority\n     */\n    private generateAccountEntity(serverTokenResponse: ServerAuthorizationTokenResponse, idToken: AuthToken, authority: Authority, authCodePayload?: AuthorizationCodePayload): AccountEntity {\n        const authorityType = authority.authorityType;\n        const cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : Constants.EMPTY_STRING;\n        const msGraphhost = authCodePayload ? authCodePayload.msgraph_host : Constants.EMPTY_STRING;\n\n        // ADFS does not require client_info in the response\n        if (authorityType === AuthorityType.Adfs) {\n            this.logger.verbose(\"Authority type is ADFS, creating ADFS account\");\n            return AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\n        }\n\n        // This fallback applies to B2C as well as they fall under an AAD account type.\n        if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === \"AAD\") {\n            throw ClientAuthError.createClientInfoEmptyError();\n        }\n\n        return serverTokenResponse.client_info ?\n            AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost) :\n            AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\n    }\n\n    /**\n     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\n     *\n     * Optionally takes a state string that is set as-is in the response.\n     *\n     * @param cacheRecord\n     * @param idTokenObj\n     * @param fromTokenCache\n     * @param stateString\n     */\n    static async generateAuthenticationResult(\n        cryptoObj: ICrypto,\n        authority: Authority,\n        cacheRecord: CacheRecord,\n        fromTokenCache: boolean,\n        request: BaseAuthRequest,\n        idTokenObj?: AuthToken,\n        requestState?: RequestStateObject,\n        serverTokenResponse?: ServerAuthorizationTokenResponse,\n        requestId?: string,\n    ): Promise<AuthenticationResult> {\n        let accessToken: string = Constants.EMPTY_STRING;\n        let responseScopes: Array<string> = [];\n        let expiresOn: Date | null = null;\n        let extExpiresOn: Date | undefined;\n        let familyId: string = Constants.EMPTY_STRING;\n\n        if (cacheRecord.accessToken) {\n            if (cacheRecord.accessToken.tokenType === AuthenticationScheme.POP) {\n                const popTokenGenerator: PopTokenGenerator = new PopTokenGenerator(cryptoObj);\n                const { secret, keyId } = cacheRecord.accessToken;\n\n                if (!keyId) {\n                    throw ClientAuthError.createKeyIdMissingError();\n                }\n\n                accessToken = await popTokenGenerator.signPopToken(secret, keyId, request);\n            } else {\n                accessToken = cacheRecord.accessToken.secret;\n            }\n            responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\n            expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\n            extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\n        }\n\n        if (cacheRecord.appMetadata) {\n            familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;\n        }\n        const uid = idTokenObj?.claims.oid || idTokenObj?.claims.sub || Constants.EMPTY_STRING;\n        const tid = idTokenObj?.claims.tid || Constants.EMPTY_STRING;\n\n        // for hybrid + native bridge enablement, send back the native account Id\n        if(serverTokenResponse?.spa_accountid && !!cacheRecord.account){\n            cacheRecord.account.nativeAccountId = serverTokenResponse?.spa_accountid;\n        }\n\n        return {\n            authority: authority.canonicalAuthority,\n            uniqueId: uid,\n            tenantId: tid,\n            scopes: responseScopes,\n            account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,\n            idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,\n            idTokenClaims: idTokenObj ? idTokenObj.claims : {},\n            accessToken: accessToken,\n            fromCache: fromTokenCache,\n            expiresOn: expiresOn,\n            correlationId: request.correlationId,\n            requestId: requestId || Constants.EMPTY_STRING,\n            extExpiresOn: extExpiresOn,\n            familyId: familyId,\n            tokenType: cacheRecord.accessToken?.tokenType || Constants.EMPTY_STRING,\n            state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\n            cloudGraphHostName: cacheRecord.account?.cloudGraphHostName || Constants.EMPTY_STRING,\n            msGraphHost: cacheRecord.account?.msGraphHost || Constants.EMPTY_STRING,\n            code: serverTokenResponse?.spa_code,\n            fromNativeBroker: false,\n        };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}