{"ast":null,"code":"/*! @azure/msal-common v13.0.0 2023-05-01 */\n'use strict';\n\nimport { __assign } from '../../_virtual/_tslib.js';\nimport { IntFields, PerformanceEventStatus } from './PerformanceEvent.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar PerformanceClient =\n/** @class */\nfunction () {\n  /**\r\n   * Creates an instance of PerformanceClient,\r\n   * an abstract class containing core performance telemetry logic.\r\n   *\r\n   * @constructor\r\n   * @param {string} clientId Client ID of the application\r\n   * @param {string} authority Authority used by the application\r\n   * @param {Logger} logger Logger used by the application\r\n   * @param {string} libraryName Name of the library\r\n   * @param {string} libraryVersion Version of the library\r\n   */\n  function PerformanceClient(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry) {\n    this.authority = authority;\n    this.libraryName = libraryName;\n    this.libraryVersion = libraryVersion;\n    this.applicationTelemetry = applicationTelemetry;\n    this.clientId = clientId;\n    this.logger = logger;\n    this.callbacks = new Map();\n    this.eventsByCorrelationId = new Map();\n    this.queueMeasurements = new Map();\n    this.preQueueTimeByCorrelationId = new Map();\n  }\n  /**\r\n   * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\r\n   * Note: this function can be changed to abstract at the next major version bump.\r\n   *\r\n   * @param {string} measureName\r\n   * @param {string} correlationId\r\n   * @returns {IPerformanceMeasurement}\r\n   */\n\n  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n\n\n  PerformanceClient.prototype.startPerformanceMeasurement = function (measureName, correlationId) {\n    return {};\n  };\n  /**\r\n   * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\r\n   * Note: this incorrectly-named function will be removed at the next major version bump.\r\n   *\r\n   * @param {string} measureName\r\n   * @param {string} correlationId\r\n   * @returns {IPerformanceMeasurement}\r\n   */\n\n  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n\n\n  PerformanceClient.prototype.startPerformanceMeasuremeant = function (measureName, correlationId) {\n    return {};\n  };\n  /**\r\n   * Get integral fields.\r\n   * Override to change the set.\r\n   */\n\n\n  PerformanceClient.prototype.getIntFields = function () {\n    return IntFields;\n  };\n  /**\r\n   * Gets map of pre-queue times by correlation Id\r\n   *\r\n   * @param {PerformanceEvents} eventName\r\n   * @param {string} correlationId\r\n   * @returns {number}\r\n   */\n\n\n  PerformanceClient.prototype.getPreQueueTime = function (eventName, correlationId) {\n    var preQueueEvent = this.preQueueTimeByCorrelationId.get(correlationId);\n\n    if (!preQueueEvent) {\n      this.logger.trace(\"PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: \" + correlationId + \", unable to add queue measurement\");\n      return;\n    } else if (preQueueEvent.name !== eventName) {\n      this.logger.trace(\"PerformanceClient.getPreQueueTime: no pre-queue time found for \" + eventName + \", unable to add queue measurement\");\n      return;\n    }\n\n    return preQueueEvent.time;\n  };\n  /**\r\n   * Calculates the difference between current time and time when function was queued.\r\n   * Note: It is possible to have 0 as the queue time if the current time and the queued time was the same.\r\n   *\r\n   * @param {number} preQueueTime\r\n   * @param {number} currentTime\r\n   * @returns {number}\r\n   */\n\n\n  PerformanceClient.prototype.calculateQueuedTime = function (preQueueTime, currentTime) {\n    if (preQueueTime < 1) {\n      this.logger.trace(\"PerformanceClient: preQueueTime should be a positive integer and not \" + preQueueTime);\n      return 0;\n    }\n\n    if (currentTime < 1) {\n      this.logger.trace(\"PerformanceClient: currentTime should be a positive integer and not \" + currentTime);\n      return 0;\n    }\n\n    if (currentTime < preQueueTime) {\n      this.logger.trace(\"PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved\");\n      return 0;\n    }\n\n    return currentTime - preQueueTime;\n  };\n  /**\r\n   * Adds queue measurement time to QueueMeasurements array for given correlation ID.\r\n   *\r\n   * @param {PerformanceEvents} eventName\r\n   * @param {?string} correlationId\r\n   * @param {?number} queueTime\r\n   * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements\r\n   * @returns\r\n   */\n\n\n  PerformanceClient.prototype.addQueueMeasurement = function (eventName, correlationId, queueTime, manuallyCompleted) {\n    if (!correlationId) {\n      this.logger.trace(\"PerformanceClient.addQueueMeasurement: correlationId not provided for \" + eventName + \", cannot add queue measurement\");\n      return;\n    }\n\n    if (queueTime === 0) {\n      // Possible for there to be no queue time after calculation\n      this.logger.trace(\"PerformanceClient.addQueueMeasurement: queue time provided for \" + eventName + \" is \" + queueTime);\n    } else if (!queueTime) {\n      this.logger.trace(\"PerformanceClient.addQueueMeasurement: no queue time provided for \" + eventName);\n      return;\n    }\n\n    var queueMeasurement = {\n      eventName: eventName,\n      queueTime: queueTime,\n      manuallyCompleted: manuallyCompleted\n    }; // Adds to existing correlation Id if present in queueMeasurements\n\n    var existingMeasurements = this.queueMeasurements.get(correlationId);\n\n    if (existingMeasurements) {\n      existingMeasurements.push(queueMeasurement);\n      this.queueMeasurements.set(correlationId, existingMeasurements);\n    } else {\n      // Sets new correlation Id if not present in queueMeasurements\n      this.logger.trace(\"PerformanceClient.addQueueMeasurement: adding correlationId \" + correlationId + \" to queue measurements\");\n      var measurementArray = [queueMeasurement];\n      this.queueMeasurements.set(correlationId, measurementArray);\n    } // Delete processed pre-queue event.\n\n\n    this.preQueueTimeByCorrelationId.delete(correlationId);\n  };\n  /**\r\n   * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\r\n   *\r\n   * @param {PerformanceEvents} measureName\r\n   * @param {?string} [correlationId]\r\n   * @returns {InProgressPerformanceEvent}\r\n   */\n\n\n  PerformanceClient.prototype.startMeasurement = function (measureName, correlationId) {\n    var _this = this;\n\n    var _a, _b; // Generate a placeholder correlation if the request does not provide one\n\n\n    var eventCorrelationId = correlationId || this.generateId();\n\n    if (!correlationId) {\n      this.logger.info(\"PerformanceClient: No correlation id provided for \" + measureName + \", generating\", eventCorrelationId);\n    } // Duplicate code to address spelling error will be removed at the next major version bump.\n\n\n    this.logger.trace(\"PerformanceClient: Performance measurement started for \" + measureName, eventCorrelationId);\n    var performanceMeasurement = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);\n    performanceMeasurement.startMeasurement();\n    var inProgressEvent = {\n      eventId: this.generateId(),\n      status: PerformanceEventStatus.InProgress,\n      authority: this.authority,\n      libraryName: this.libraryName,\n      libraryVersion: this.libraryVersion,\n      clientId: this.clientId,\n      name: measureName,\n      startTimeMs: Date.now(),\n      correlationId: eventCorrelationId,\n      appName: (_a = this.applicationTelemetry) === null || _a === void 0 ? void 0 : _a.appName,\n      appVersion: (_b = this.applicationTelemetry) === null || _b === void 0 ? void 0 : _b.appVersion\n    }; // Store in progress events so they can be discarded if not ended properly\n\n    this.cacheEventByCorrelationId(inProgressEvent); // Return the event and functions the caller can use to properly end/flush the measurement\n\n    return {\n      endMeasurement: function (event) {\n        return _this.endMeasurement(__assign(__assign({}, inProgressEvent), event), performanceMeasurement);\n      },\n      discardMeasurement: function () {\n        return _this.discardMeasurements(inProgressEvent.correlationId);\n      },\n      addStaticFields: function (fields) {\n        return _this.addStaticFields(fields, inProgressEvent.correlationId);\n      },\n      increment: function (counters) {\n        return _this.increment(counters, inProgressEvent.correlationId);\n      },\n      measurement: performanceMeasurement,\n      event: inProgressEvent\n    };\n  };\n  /**\r\n   * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\r\n   * as consumers should instead use the function returned by startMeasurement.\r\n   * Adds a new field named as \"[event name]DurationMs\" for sub-measurements, completes and emits an event\r\n   * otherwise.\r\n   *\r\n   * @param {PerformanceEvent} event\r\n   * @param {IPerformanceMeasurement} measurement\r\n   * @returns {(PerformanceEvent | null)}\r\n   */\n\n\n  PerformanceClient.prototype.endMeasurement = function (event, measurement) {\n    var _this = this;\n\n    var _a, _b;\n\n    var rootEvent = this.eventsByCorrelationId.get(event.correlationId);\n\n    if (!rootEvent) {\n      this.logger.trace(\"PerformanceClient: Measurement not found for \" + event.eventId, event.correlationId);\n      return null;\n    }\n\n    var isRoot = event.eventId === rootEvent.eventId;\n    var queueInfo = {\n      totalQueueTime: 0,\n      totalQueueCount: 0,\n      manuallyCompletedCount: 0\n    };\n\n    if (isRoot) {\n      queueInfo = this.getQueueInfo(event.correlationId);\n      this.discardCache(rootEvent.correlationId);\n    } else {\n      (_a = rootEvent.incompleteSubMeasurements) === null || _a === void 0 ? void 0 : _a.delete(event.eventId);\n    }\n\n    measurement === null || measurement === void 0 ? void 0 : measurement.endMeasurement();\n    var durationMs = measurement === null || measurement === void 0 ? void 0 : measurement.flushMeasurement(); // null indicates no measurement was taken (e.g. needed performance APIs not present)\n\n    if (!durationMs) {\n      this.logger.trace(\"PerformanceClient: Performance measurement not taken\", rootEvent.correlationId);\n      return null;\n    }\n\n    this.logger.trace(\"PerformanceClient: Performance measurement ended for \" + event.name + \": \" + durationMs + \" ms\", event.correlationId); // Add sub-measurement attribute to root event.\n\n    if (!isRoot) {\n      rootEvent[event.name + \"DurationMs\"] = Math.floor(durationMs);\n      return __assign({}, rootEvent);\n    }\n\n    var finalEvent = __assign(__assign({}, rootEvent), event);\n\n    var incompleteSubsCount = 0; // Incomplete sub-measurements are discarded. They are likely an instrumentation bug that should be fixed.\n\n    (_b = finalEvent.incompleteSubMeasurements) === null || _b === void 0 ? void 0 : _b.forEach(function (subMeasurement) {\n      _this.logger.trace(\"PerformanceClient: Incomplete submeasurement \" + subMeasurement.name + \" found for \" + event.name, finalEvent.correlationId);\n\n      incompleteSubsCount++;\n    });\n    finalEvent.incompleteSubMeasurements = undefined;\n    finalEvent = __assign(__assign({}, finalEvent), {\n      durationMs: Math.round(durationMs),\n      queuedTimeMs: queueInfo.totalQueueTime,\n      queuedCount: queueInfo.totalQueueCount,\n      queuedManuallyCompletedCount: queueInfo.manuallyCompletedCount,\n      status: PerformanceEventStatus.Completed,\n      incompleteSubsCount: incompleteSubsCount\n    });\n    this.truncateIntegralFields(finalEvent, this.getIntFields());\n    this.emitEvents([finalEvent], event.correlationId);\n    return finalEvent;\n  };\n  /**\r\n   * Saves extra information to be emitted when the measurements are flushed\r\n   * @param fields\r\n   * @param correlationId\r\n   */\n\n\n  PerformanceClient.prototype.addStaticFields = function (fields, correlationId) {\n    this.logger.trace(\"PerformanceClient: Updating static fields\");\n    var event = this.eventsByCorrelationId.get(correlationId);\n\n    if (event) {\n      this.eventsByCorrelationId.set(correlationId, __assign(__assign({}, event), fields));\n    } else {\n      this.logger.trace(\"PerformanceClient: Event not found for\", correlationId);\n    }\n  };\n  /**\r\n   * Increment counters to be emitted when the measurements are flushed\r\n   * @param counters {Counters}\r\n   * @param correlationId {string} correlation identifier\r\n   */\n\n\n  PerformanceClient.prototype.increment = function (counters, correlationId) {\n    this.logger.trace(\"PerformanceClient: Updating counters\");\n    var event = this.eventsByCorrelationId.get(correlationId);\n\n    if (event) {\n      for (var counter in counters) {\n        if (!event.hasOwnProperty(counter)) {\n          event[counter] = 0;\n        }\n\n        event[counter] += counters[counter];\n      }\n    } else {\n      this.logger.trace(\"PerformanceClient: Event not found for\", correlationId);\n    }\n  };\n  /**\r\n   * Upserts event into event cache.\r\n   * First key is the correlation id, second key is the event id.\r\n   * Allows for events to be grouped by correlation id,\r\n   * and to easily allow for properties on them to be updated.\r\n   *\r\n   * @private\r\n   * @param {PerformanceEvent} event\r\n   */\n\n\n  PerformanceClient.prototype.cacheEventByCorrelationId = function (event) {\n    var rootEvent = this.eventsByCorrelationId.get(event.correlationId);\n\n    if (rootEvent) {\n      this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" added/updated\", event.correlationId);\n      rootEvent.incompleteSubMeasurements = rootEvent.incompleteSubMeasurements || new Map();\n      rootEvent.incompleteSubMeasurements.set(event.eventId, {\n        name: event.name,\n        startTimeMs: event.startTimeMs\n      });\n    } else {\n      this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" started\", event.correlationId);\n      this.eventsByCorrelationId.set(event.correlationId, __assign({}, event));\n    }\n  };\n\n  PerformanceClient.prototype.getQueueInfo = function (correlationId) {\n    var queueMeasurementForCorrelationId = this.queueMeasurements.get(correlationId);\n\n    if (!queueMeasurementForCorrelationId) {\n      this.logger.trace(\"PerformanceClient: no queue measurements found for for correlationId: \" + correlationId);\n    }\n\n    var totalQueueTime = 0;\n    var totalQueueCount = 0;\n    var manuallyCompletedCount = 0;\n    queueMeasurementForCorrelationId === null || queueMeasurementForCorrelationId === void 0 ? void 0 : queueMeasurementForCorrelationId.forEach(function (measurement) {\n      totalQueueTime += measurement.queueTime;\n      totalQueueCount++;\n      manuallyCompletedCount += measurement.manuallyCompleted ? 1 : 0;\n    });\n    return {\n      totalQueueTime: totalQueueTime,\n      totalQueueCount: totalQueueCount,\n      manuallyCompletedCount: manuallyCompletedCount\n    };\n  };\n  /**\r\n   * Removes measurements for a given correlation id.\r\n   *\r\n   * @param {string} correlationId\r\n   */\n\n\n  PerformanceClient.prototype.discardMeasurements = function (correlationId) {\n    this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\n    this.eventsByCorrelationId.delete(correlationId);\n  };\n  /**\r\n   * Removes cache for a given correlation id.\r\n   *\r\n   * @param {string} correlationId correlation identifier\r\n   */\n\n\n  PerformanceClient.prototype.discardCache = function (correlationId) {\n    this.discardMeasurements(correlationId);\n    this.logger.trace(\"PerformanceClient: QueueMeasurements discarded\", correlationId);\n    this.queueMeasurements.delete(correlationId);\n    this.logger.trace(\"PerformanceClient: Pre-queue times discarded\", correlationId);\n    this.preQueueTimeByCorrelationId.delete(correlationId);\n  };\n  /**\r\n   * Registers a callback function to receive performance events.\r\n   *\r\n   * @param {PerformanceCallbackFunction} callback\r\n   * @returns {string}\r\n   */\n\n\n  PerformanceClient.prototype.addPerformanceCallback = function (callback) {\n    var callbackId = this.generateId();\n    this.callbacks.set(callbackId, callback);\n    this.logger.verbose(\"PerformanceClient: Performance callback registered with id: \" + callbackId);\n    return callbackId;\n  };\n  /**\r\n   * Removes a callback registered with addPerformanceCallback.\r\n   *\r\n   * @param {string} callbackId\r\n   * @returns {boolean}\r\n   */\n\n\n  PerformanceClient.prototype.removePerformanceCallback = function (callbackId) {\n    var result = this.callbacks.delete(callbackId);\n\n    if (result) {\n      this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" removed.\");\n    } else {\n      this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" not removed.\");\n    }\n\n    return result;\n  };\n  /**\r\n   * Emits events to all registered callbacks.\r\n   *\r\n   * @param {PerformanceEvent[]} events\r\n   * @param {?string} [correlationId]\r\n   */\n\n\n  PerformanceClient.prototype.emitEvents = function (events, correlationId) {\n    var _this = this;\n\n    this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\n    this.callbacks.forEach(function (callback, callbackId) {\n      _this.logger.trace(\"PerformanceClient: Emitting event to callback \" + callbackId, correlationId);\n\n      callback.apply(null, [events]);\n    });\n  };\n  /**\r\n   * Enforce truncation of integral fields in performance event.\r\n   * @param {PerformanceEvent} event performance event to update.\r\n   * @param {Set<string>} intFields integral fields.\r\n   */\n\n\n  PerformanceClient.prototype.truncateIntegralFields = function (event, intFields) {\n    intFields.forEach(function (key) {\n      if (key in event && typeof event[key] === \"number\") {\n        event[key] = Math.floor(event[key]);\n      }\n    });\n  };\n\n  return PerformanceClient;\n}();\n\nexport { PerformanceClient };","map":{"version":3,"mappings":"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","names":["PerformanceClient","clientId","authority","logger","libraryName","libraryVersion","applicationTelemetry","callbacks","Map","eventsByCorrelationId","queueMeasurements","preQueueTimeByCorrelationId","measureName","correlationId","IntFields","eventName","preQueueEvent","get","trace","name","time","preQueueTime","currentTime","addQueueMeasurement","queueTime","manuallyCompleted","queueMeasurement","existingMeasurements","push","set","measurementArray","delete","_this","eventCorrelationId","generateId","info","performanceMeasurement","startPerformanceMeasuremeant","startMeasurement","inProgressEvent","eventId","status","PerformanceEventStatus","InProgress","startTimeMs","Date","now","appName","_a","appVersion","_b","cacheEventByCorrelationId","endMeasurement","event","__assign","discardMeasurement","discardMeasurements","addStaticFields","fields","increment","counters","measurement","rootEvent","isRoot","queueInfo","totalQueueTime","totalQueueCount","manuallyCompletedCount","getQueueInfo","discardCache","incompleteSubMeasurements","durationMs","flushMeasurement","Math","floor","finalEvent","incompleteSubsCount","forEach","subMeasurement","undefined","round","queuedTimeMs","queuedCount","queuedManuallyCompletedCount","Completed","truncateIntegralFields","getIntFields","emitEvents","counter","hasOwnProperty","queueMeasurementForCorrelationId","addPerformanceCallback","callback","callbackId","verbose","removePerformanceCallback","result","events","apply","intFields","key"],"sources":["/Users/edwardlee/Downloads/msal-react-demo/node_modules/@azure/msal-common/src/telemetry/performance/PerformanceClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ApplicationTelemetry } from \"../../config/ClientConfiguration\";\nimport { Logger } from \"../../logger/Logger\";\nimport {\n    InProgressPerformanceEvent,\n    IPerformanceClient,\n    PerformanceCallbackFunction,\n    QueueMeasurement\n} from \"./IPerformanceClient\";\nimport { IPerformanceMeasurement } from \"./IPerformanceMeasurement\";\nimport {\n    Counters,\n    IntFields,\n    PerformanceEvent,\n    PerformanceEvents,\n    PerformanceEventStatus,\n    StaticFields\n} from \"./PerformanceEvent\";\n\nexport interface PreQueueEvent {\n    name: PerformanceEvents;\n    time: number;\n}\n\nexport abstract class PerformanceClient implements IPerformanceClient {\n    protected authority: string;\n    protected libraryName: string;\n    protected libraryVersion: string;\n    protected applicationTelemetry: ApplicationTelemetry;\n    protected clientId: string;\n    protected logger: Logger;\n    protected callbacks: Map<string, PerformanceCallbackFunction>;\n\n    /**\n     * Multiple events with the same correlation id.\n     * @protected\n     * @type {Map<string, PerformanceEvent>}\n     */\n    protected eventsByCorrelationId: Map<string, PerformanceEvent>;\n\n    /**\n     * Map of pre-queue times by correlation Id\n     *\n     * @protected\n     * @type {Map<string, PreQueueEvent>}\n     */\n    protected preQueueTimeByCorrelationId: Map<string, PreQueueEvent>;\n\n    /**\n     * Map of queue measurements by correlation Id\n     *\n     * @protected\n     * @type {Map<string, Array<QueueMeasurement>>}\n     */\n    protected queueMeasurements: Map<string, Array<QueueMeasurement>>;\n\n    /**\n     * Creates an instance of PerformanceClient,\n     * an abstract class containing core performance telemetry logic.\n     *\n     * @constructor\n     * @param {string} clientId Client ID of the application\n     * @param {string} authority Authority used by the application\n     * @param {Logger} logger Logger used by the application\n     * @param {string} libraryName Name of the library\n     * @param {string} libraryVersion Version of the library\n     */\n    constructor(clientId: string, authority: string, logger: Logger, libraryName: string, libraryVersion: string, applicationTelemetry: ApplicationTelemetry) {\n        this.authority = authority;\n        this.libraryName = libraryName;\n        this.libraryVersion = libraryVersion;\n        this.applicationTelemetry = applicationTelemetry;\n        this.clientId = clientId;\n        this.logger = logger;\n        this.callbacks = new Map();\n        this.eventsByCorrelationId = new Map();\n        this.queueMeasurements = new Map();\n        this.preQueueTimeByCorrelationId = new Map();\n    }\n\n    /**\n     * Generates and returns a unique id, typically a guid.\n     *\n     * @abstract\n     * @returns {string}\n     */\n    abstract generateId(): string;\n\n    /**\n     * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\n     * Note: this function can be changed to abstract at the next major version bump.\n     *\n     * @param {string} measureName\n     * @param {string} correlationId\n     * @returns {IPerformanceMeasurement}\n     */\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n    startPerformanceMeasurement(measureName: string, correlationId: string): IPerformanceMeasurement {\n        return {} as IPerformanceMeasurement;\n    }\n\n    /**\n     * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\n     * Note: this incorrectly-named function will be removed at the next major version bump.\n     *\n     * @param {string} measureName\n     * @param {string} correlationId\n     * @returns {IPerformanceMeasurement}\n     */\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n    startPerformanceMeasuremeant(measureName: string, correlationId: string): IPerformanceMeasurement {\n        return {} as IPerformanceMeasurement;\n    }\n\n    /**\n     * Sets pre-queue time by correlation Id\n     *\n     * @abstract\n     * @param {PerformanceEvents} eventName\n     * @param {string} correlationId\n     * @returns\n     */\n    abstract setPreQueueTime(eventName: PerformanceEvents, correlationId?: string): void;\n\n    /**\n     * Get integral fields.\n     * Override to change the set.\n     */\n    getIntFields(): ReadonlySet<string> {\n        return IntFields;\n    }\n\n    /**\n     * Gets map of pre-queue times by correlation Id\n     *\n     * @param {PerformanceEvents} eventName\n     * @param {string} correlationId\n     * @returns {number}\n     */\n    getPreQueueTime(eventName: PerformanceEvents, correlationId: string): number | void {\n        const preQueueEvent: PreQueueEvent | undefined = this.preQueueTimeByCorrelationId.get(correlationId);\n\n        if (!preQueueEvent) {\n            this.logger.trace(`PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: ${correlationId}, unable to add queue measurement`);\n            return;\n        } else if (preQueueEvent.name !== eventName) {\n            this.logger.trace(`PerformanceClient.getPreQueueTime: no pre-queue time found for ${eventName}, unable to add queue measurement`);\n            return;\n        }\n\n        return preQueueEvent.time;\n    }\n\n    /**\n     * Calculates the difference between current time and time when function was queued.\n     * Note: It is possible to have 0 as the queue time if the current time and the queued time was the same.\n     *\n     * @param {number} preQueueTime\n     * @param {number} currentTime\n     * @returns {number}\n     */\n    calculateQueuedTime(preQueueTime: number, currentTime: number): number {\n        if (preQueueTime < 1) {\n            this.logger.trace(`PerformanceClient: preQueueTime should be a positive integer and not ${preQueueTime}`);\n            return 0;\n        }\n\n        if (currentTime < 1) {\n            this.logger.trace(`PerformanceClient: currentTime should be a positive integer and not ${currentTime}`);\n            return 0;\n        }\n\n        if (currentTime < preQueueTime) {\n            this.logger.trace(\"PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved\");\n            return 0;\n        }\n\n        return currentTime-preQueueTime;\n    }\n\n    /**\n     * Adds queue measurement time to QueueMeasurements array for given correlation ID.\n     *\n     * @param {PerformanceEvents} eventName\n     * @param {?string} correlationId\n     * @param {?number} queueTime\n     * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements\n     * @returns\n     */\n    addQueueMeasurement(eventName: PerformanceEvents, correlationId?: string, queueTime?: number, manuallyCompleted?: boolean): void {\n        if (!correlationId) {\n            this.logger.trace(`PerformanceClient.addQueueMeasurement: correlationId not provided for ${eventName}, cannot add queue measurement`);\n            return;\n        }\n\n        if (queueTime === 0) {\n            // Possible for there to be no queue time after calculation\n            this.logger.trace(`PerformanceClient.addQueueMeasurement: queue time provided for ${eventName} is ${queueTime}`);\n        } else if (!queueTime) {\n            this.logger.trace(`PerformanceClient.addQueueMeasurement: no queue time provided for ${eventName}`);\n            return;\n        }\n\n        const queueMeasurement: QueueMeasurement = {eventName, queueTime, manuallyCompleted};\n\n        // Adds to existing correlation Id if present in queueMeasurements\n        const existingMeasurements = this.queueMeasurements.get(correlationId);\n        if (existingMeasurements) {\n            existingMeasurements.push(queueMeasurement);\n            this.queueMeasurements.set(correlationId, existingMeasurements);\n        } else {\n            // Sets new correlation Id if not present in queueMeasurements\n            this.logger.trace(`PerformanceClient.addQueueMeasurement: adding correlationId ${correlationId} to queue measurements`);\n            const measurementArray = [queueMeasurement];\n            this.queueMeasurements.set(correlationId, measurementArray);\n        }\n        // Delete processed pre-queue event.\n        this.preQueueTimeByCorrelationId.delete(correlationId);\n    }\n\n    /**\n     * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\n     *\n     * @param {PerformanceEvents} measureName\n     * @param {?string} [correlationId]\n     * @returns {InProgressPerformanceEvent}\n     */\n    startMeasurement(measureName: PerformanceEvents, correlationId?: string): InProgressPerformanceEvent {\n        // Generate a placeholder correlation if the request does not provide one\n        const eventCorrelationId = correlationId || this.generateId();\n        if (!correlationId) {\n            this.logger.info(`PerformanceClient: No correlation id provided for ${measureName}, generating`, eventCorrelationId);\n        }\n\n        // Duplicate code to address spelling error will be removed at the next major version bump.\n        this.logger.trace(`PerformanceClient: Performance measurement started for ${measureName}`, eventCorrelationId);\n        const performanceMeasurement = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);\n        performanceMeasurement.startMeasurement();\n\n        const inProgressEvent: PerformanceEvent = {\n            eventId: this.generateId(),\n            status: PerformanceEventStatus.InProgress,\n            authority: this.authority,\n            libraryName: this.libraryName,\n            libraryVersion: this.libraryVersion,\n            clientId: this.clientId,\n            name: measureName,\n            startTimeMs: Date.now(),\n            correlationId: eventCorrelationId,\n            appName: this.applicationTelemetry?.appName,\n            appVersion: this.applicationTelemetry?.appVersion,\n        };\n\n        // Store in progress events so they can be discarded if not ended properly\n        this.cacheEventByCorrelationId(inProgressEvent);\n\n        // Return the event and functions the caller can use to properly end/flush the measurement\n        return {\n            endMeasurement: (event?: Partial<PerformanceEvent>): PerformanceEvent | null => {\n                return this.endMeasurement({\n                    // Initial set of event properties\n                    ...inProgressEvent,\n                    // Properties set when event ends\n                    ...event\n                },\n                performanceMeasurement);\n            },\n            discardMeasurement: () => {\n                return this.discardMeasurements(inProgressEvent.correlationId);\n            },\n            addStaticFields: (fields: StaticFields) => {\n                return this.addStaticFields(fields, inProgressEvent.correlationId);\n            },\n            increment: (counters: Counters) => {\n                return this.increment(counters, inProgressEvent.correlationId);\n            },\n            measurement: performanceMeasurement,\n            event: inProgressEvent\n        };\n\n    }\n\n    /**\n     * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\n     * as consumers should instead use the function returned by startMeasurement.\n     * Adds a new field named as \"[event name]DurationMs\" for sub-measurements, completes and emits an event\n     * otherwise.\n     *\n     * @param {PerformanceEvent} event\n     * @param {IPerformanceMeasurement} measurement\n     * @returns {(PerformanceEvent | null)}\n     */\n    endMeasurement(event: PerformanceEvent, measurement?: IPerformanceMeasurement): PerformanceEvent | null {\n        const rootEvent: PerformanceEvent | undefined = this.eventsByCorrelationId.get(event.correlationId);\n        if (!rootEvent) {\n            this.logger.trace(`PerformanceClient: Measurement not found for ${event.eventId}`, event.correlationId);\n            return null;\n        }\n\n        const isRoot = event.eventId === rootEvent.eventId;\n        let queueInfo = {\n            totalQueueTime: 0,\n            totalQueueCount: 0,\n            manuallyCompletedCount: 0\n        };\n        if (isRoot) {\n            queueInfo = this.getQueueInfo(event.correlationId);\n            this.discardCache(rootEvent.correlationId);\n        } else {\n            rootEvent.incompleteSubMeasurements?.delete(event.eventId);\n        }\n\n        measurement?.endMeasurement();\n        const durationMs = measurement?.flushMeasurement();\n        // null indicates no measurement was taken (e.g. needed performance APIs not present)\n        if (!durationMs) {\n            this.logger.trace(\"PerformanceClient: Performance measurement not taken\", rootEvent.correlationId);\n            return null;\n        }\n\n        this.logger.trace(`PerformanceClient: Performance measurement ended for ${event.name}: ${durationMs} ms`, event.correlationId);\n\n        // Add sub-measurement attribute to root event.\n        if (!isRoot) {\n            rootEvent[event.name + \"DurationMs\"] = Math.floor(durationMs);\n            return { ...rootEvent };\n        }\n\n        let finalEvent: PerformanceEvent = { ...rootEvent, ...event };\n        let incompleteSubsCount: number = 0;\n        // Incomplete sub-measurements are discarded. They are likely an instrumentation bug that should be fixed.\n        finalEvent.incompleteSubMeasurements?.forEach(subMeasurement => {\n            this.logger.trace(`PerformanceClient: Incomplete submeasurement ${subMeasurement.name} found for ${event.name}`, finalEvent.correlationId);\n            incompleteSubsCount++;\n        });\n        finalEvent.incompleteSubMeasurements = undefined;\n\n        finalEvent = {\n            ...finalEvent,\n            durationMs: Math.round(durationMs),\n            queuedTimeMs: queueInfo.totalQueueTime,\n            queuedCount: queueInfo.totalQueueCount,\n            queuedManuallyCompletedCount: queueInfo.manuallyCompletedCount,\n            status: PerformanceEventStatus.Completed,\n            incompleteSubsCount\n        };\n        this.truncateIntegralFields(finalEvent, this.getIntFields());\n        this.emitEvents([finalEvent], event.correlationId);\n\n        return finalEvent;\n    }\n\n    /**\n     * Saves extra information to be emitted when the measurements are flushed\n     * @param fields\n     * @param correlationId\n     */\n    addStaticFields(fields: StaticFields, correlationId: string) : void {\n        this.logger.trace(\"PerformanceClient: Updating static fields\");\n        const event = this.eventsByCorrelationId.get(correlationId);\n        if (event) {\n            this.eventsByCorrelationId.set(correlationId, {...event, ...fields});\n        } else {\n            this.logger.trace(\"PerformanceClient: Event not found for\", correlationId);\n        }\n    }\n\n    /**\n     * Increment counters to be emitted when the measurements are flushed\n     * @param counters {Counters}\n     * @param correlationId {string} correlation identifier\n     */\n    increment(counters: Counters, correlationId: string): void {\n        this.logger.trace(\"PerformanceClient: Updating counters\");\n        const event = this.eventsByCorrelationId.get(correlationId);\n        if (event) {\n            for (const counter in counters) {\n                if (!event.hasOwnProperty(counter)) {\n                    event[counter] = 0;\n                }\n                event[counter] += counters[counter];\n            }\n        } else {\n            this.logger.trace(\"PerformanceClient: Event not found for\", correlationId);\n        }\n    }\n\n    /**\n     * Upserts event into event cache.\n     * First key is the correlation id, second key is the event id.\n     * Allows for events to be grouped by correlation id,\n     * and to easily allow for properties on them to be updated.\n     *\n     * @private\n     * @param {PerformanceEvent} event\n     */\n    private cacheEventByCorrelationId(event: PerformanceEvent) {\n        const rootEvent = this.eventsByCorrelationId.get(event.correlationId);\n        if (rootEvent) {\n            this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} added/updated`, event.correlationId);\n            rootEvent.incompleteSubMeasurements = rootEvent.incompleteSubMeasurements || new Map();\n            rootEvent.incompleteSubMeasurements.set(event.eventId, {name: event.name, startTimeMs: event.startTimeMs });\n        } else {\n            this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} started`, event.correlationId);\n            this.eventsByCorrelationId.set(event.correlationId, { ...event });\n        }\n    }\n\n    private getQueueInfo(correlationId: string): { totalQueueTime: number, totalQueueCount: number, manuallyCompletedCount: number } {\n        const queueMeasurementForCorrelationId = this.queueMeasurements.get(correlationId);\n        if (!queueMeasurementForCorrelationId) {\n            this.logger.trace(`PerformanceClient: no queue measurements found for for correlationId: ${correlationId}`);\n        }\n\n        let totalQueueTime = 0;\n        let totalQueueCount = 0;\n        let manuallyCompletedCount = 0;\n        queueMeasurementForCorrelationId?.forEach((measurement) => {\n            totalQueueTime += measurement.queueTime;\n            totalQueueCount++;\n            manuallyCompletedCount += measurement.manuallyCompleted ? 1 : 0;\n        });\n\n        return {\n            totalQueueTime,\n            totalQueueCount,\n            manuallyCompletedCount\n        };\n    }\n\n    /**\n     * Removes measurements for a given correlation id.\n     *\n     * @param {string} correlationId\n     */\n    discardMeasurements(correlationId: string): void {\n        this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\n        this.eventsByCorrelationId.delete(correlationId);\n    }\n\n    /**\n     * Removes cache for a given correlation id.\n     *\n     * @param {string} correlationId correlation identifier\n     */\n    private discardCache(correlationId: string): void {\n        this.discardMeasurements(correlationId);\n\n        this.logger.trace(\"PerformanceClient: QueueMeasurements discarded\", correlationId);\n        this.queueMeasurements.delete(correlationId);\n\n        this.logger.trace(\"PerformanceClient: Pre-queue times discarded\", correlationId);\n        this.preQueueTimeByCorrelationId.delete(correlationId);\n    }\n\n    /**\n     * Registers a callback function to receive performance events.\n     *\n     * @param {PerformanceCallbackFunction} callback\n     * @returns {string}\n     */\n    addPerformanceCallback(callback: PerformanceCallbackFunction): string {\n        const callbackId = this.generateId();\n        this.callbacks.set(callbackId, callback);\n        this.logger.verbose(`PerformanceClient: Performance callback registered with id: ${callbackId}`);\n\n        return callbackId;\n    }\n\n    /**\n     * Removes a callback registered with addPerformanceCallback.\n     *\n     * @param {string} callbackId\n     * @returns {boolean}\n     */\n    removePerformanceCallback(callbackId: string): boolean {\n        const result = this.callbacks.delete(callbackId);\n\n        if (result) {\n            this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} removed.`);\n        } else {\n            this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} not removed.`);\n        }\n\n        return result;\n    }\n\n    /**\n     * Emits events to all registered callbacks.\n     *\n     * @param {PerformanceEvent[]} events\n     * @param {?string} [correlationId]\n     */\n    emitEvents(events: PerformanceEvent[], correlationId: string): void {\n        this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\n\n        this.callbacks.forEach((callback: PerformanceCallbackFunction, callbackId: string) => {\n            this.logger.trace(`PerformanceClient: Emitting event to callback ${callbackId}`, correlationId);\n            callback.apply(null, [events]);\n        });\n    }\n\n    /**\n     * Enforce truncation of integral fields in performance event.\n     * @param {PerformanceEvent} event performance event to update.\n     * @param {Set<string>} intFields integral fields.\n     */\n    private truncateIntegralFields(event: PerformanceEvent, intFields: ReadonlySet<string>): void {\n        intFields.forEach((key) => {\n            if (key in event && typeof event[key] === \"number\") {\n                event[key] = Math.floor(event[key]);\n            }\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}