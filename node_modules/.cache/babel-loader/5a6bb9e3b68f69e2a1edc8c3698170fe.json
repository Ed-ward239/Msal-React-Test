{"ast":null,"code":"/*! @azure/msal-common v13.0.0 2023-05-01 */\n'use strict';\n\nimport { __awaiter, __generator, __assign, __extends } from '../_virtual/_tslib.js';\nimport { Separators, CredentialType, AuthenticationScheme, THE_FAMILY_ID, APP_METADATA, AUTHORITY_METADATA_CONSTANTS } from '../utils/Constants.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from './entities/AccountEntity.js';\nimport { AuthError } from '../error/AuthError.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { name, version } from '../packageMetadata.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n */\n\nvar CacheManager =\n/** @class */\nfunction () {\n  function CacheManager(clientId, cryptoImpl, logger) {\n    this.clientId = clientId;\n    this.cryptoImpl = cryptoImpl;\n    this.commonLogger = logger.clone(name, version);\n  }\n  /**\r\n   * Returns all accounts in cache\r\n   */\n\n\n  CacheManager.prototype.getAllAccounts = function () {\n    var _this = this;\n\n    var allAccountKeys = this.getAccountKeys();\n\n    if (allAccountKeys.length < 1) {\n      return [];\n    }\n\n    var accountEntities = allAccountKeys.reduce(function (accounts, key) {\n      var entity = _this.getAccount(key);\n\n      if (!entity) {\n        return accounts;\n      }\n\n      accounts.push(entity);\n      return accounts;\n    }, []);\n\n    if (accountEntities.length < 1) {\n      return [];\n    } else {\n      var allAccounts = accountEntities.map(function (accountEntity) {\n        return _this.getAccountInfoFromEntity(accountEntity);\n      });\n      return allAccounts;\n    }\n  };\n  /**\r\n   * Gets accountInfo object based on provided filters\r\n   */\n\n\n  CacheManager.prototype.getAccountInfoFilteredBy = function (accountFilter) {\n    var allAccounts = this.getAccountsFilteredBy(accountFilter);\n\n    if (allAccounts.length > 0) {\n      return this.getAccountInfoFromEntity(allAccounts[0]);\n    } else {\n      return null;\n    }\n  };\n\n  CacheManager.prototype.getAccountInfoFromEntity = function (accountEntity) {\n    var accountInfo = accountEntity.getAccountInfo();\n    var idToken = this.getIdToken(accountInfo);\n\n    if (idToken) {\n      accountInfo.idToken = idToken.secret;\n      accountInfo.idTokenClaims = new AuthToken(idToken.secret, this.cryptoImpl).claims;\n    }\n\n    return accountInfo;\n  };\n  /**\r\n   * saves a cache record\r\n   * @param cacheRecord\r\n   */\n\n\n  CacheManager.prototype.saveCacheRecord = function (cacheRecord) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!cacheRecord) {\n              throw ClientAuthError.createNullOrUndefinedCacheRecord();\n            }\n\n            if (!!cacheRecord.account) {\n              this.setAccount(cacheRecord.account);\n            }\n\n            if (!!cacheRecord.idToken) {\n              this.setIdTokenCredential(cacheRecord.idToken);\n            }\n\n            if (!!!cacheRecord.accessToken) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.saveAccessToken(cacheRecord.accessToken)];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            if (!!cacheRecord.refreshToken) {\n              this.setRefreshTokenCredential(cacheRecord.refreshToken);\n            }\n\n            if (!!cacheRecord.appMetadata) {\n              this.setAppMetadata(cacheRecord.appMetadata);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * saves access token credential\r\n   * @param credential\r\n   */\n\n\n  CacheManager.prototype.saveAccessToken = function (credential) {\n    return __awaiter(this, void 0, void 0, function () {\n      var accessTokenFilter, tokenKeys, currentScopes, removedAccessTokens;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            accessTokenFilter = {\n              clientId: credential.clientId,\n              credentialType: credential.credentialType,\n              environment: credential.environment,\n              homeAccountId: credential.homeAccountId,\n              realm: credential.realm,\n              tokenType: credential.tokenType,\n              requestedClaimsHash: credential.requestedClaimsHash\n            };\n            tokenKeys = this.getTokenKeys();\n            currentScopes = ScopeSet.fromString(credential.target);\n            removedAccessTokens = [];\n            tokenKeys.accessToken.forEach(function (key) {\n              if (!_this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {\n                return;\n              }\n\n              var tokenEntity = _this.getAccessTokenCredential(key);\n\n              if (tokenEntity && _this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {\n                var tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n\n                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n                  removedAccessTokens.push(_this.removeAccessToken(key));\n                }\n              }\n            });\n            return [4\n            /*yield*/\n            , Promise.all(removedAccessTokens)];\n\n          case 1:\n            _a.sent();\n\n            this.setAccessTokenCredential(credential);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n   * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param realm\r\n   */\n\n\n  CacheManager.prototype.getAccountsFilteredBy = function (accountFilter) {\n    var _this = this;\n\n    var allAccountKeys = this.getAccountKeys();\n    var matchingAccounts = [];\n    allAccountKeys.forEach(function (cacheKey) {\n      if (!_this.isAccountKey(cacheKey, accountFilter.homeAccountId, accountFilter.realm)) {\n        // Don't parse value if the key doesn't match the account filters\n        return;\n      }\n\n      var entity = _this.getAccount(cacheKey);\n\n      if (!entity) {\n        return;\n      }\n\n      if (!!accountFilter.homeAccountId && !_this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {\n        return;\n      }\n\n      if (!!accountFilter.localAccountId && !_this.matchLocalAccountId(entity, accountFilter.localAccountId)) {\n        return;\n      }\n\n      if (!!accountFilter.username && !_this.matchUsername(entity, accountFilter.username)) {\n        return;\n      }\n\n      if (!!accountFilter.environment && !_this.matchEnvironment(entity, accountFilter.environment)) {\n        return;\n      }\n\n      if (!!accountFilter.realm && !_this.matchRealm(entity, accountFilter.realm)) {\n        return;\n      }\n\n      if (!!accountFilter.nativeAccountId && !_this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {\n        return;\n      }\n\n      matchingAccounts.push(entity);\n    });\n    return matchingAccounts;\n  };\n  /**\r\n   * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided\r\n   * @param key\r\n   * @param homeAccountId\r\n   * @param tenantId\r\n   * @returns\r\n   */\n\n\n  CacheManager.prototype.isAccountKey = function (key, homeAccountId, tenantId) {\n    if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {\n      // Account cache keys contain 3 items separated by '-' (each item may also contain '-')\n      return false;\n    }\n\n    if (homeAccountId && !key.toLowerCase().includes(homeAccountId.toLowerCase())) {\n      return false;\n    }\n\n    if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {\n      return false;\n    } // Do not check environment as aliasing can cause false negatives\n\n\n    return true;\n  };\n  /**\r\n   * Returns true if the given key matches our credential key schema.\r\n   * @param key\r\n   */\n\n\n  CacheManager.prototype.isCredentialKey = function (key) {\n    if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {\n      // Credential cache keys contain 6 items separated by '-' (each item may also contain '-')\n      return false;\n    }\n\n    var lowerCaseKey = key.toLowerCase(); // Credential keys must indicate what credential type they represent\n\n    if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) === -1) {\n      return false;\n    }\n\n    if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) > -1) {\n      // Refresh tokens must contain the client id or family id\n      var clientIdValidation = \"\" + CredentialType.REFRESH_TOKEN + Separators.CACHE_KEY_SEPARATOR + this.clientId + Separators.CACHE_KEY_SEPARATOR;\n      var familyIdValidation = \"\" + CredentialType.REFRESH_TOKEN + Separators.CACHE_KEY_SEPARATOR + THE_FAMILY_ID + Separators.CACHE_KEY_SEPARATOR;\n\n      if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 && lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {\n        return false;\n      }\n    } else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {\n      // Tokens must contain the clientId\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Returns whether or not the given credential entity matches the filter\r\n   * @param entity\r\n   * @param filter\r\n   * @returns\r\n   */\n\n\n  CacheManager.prototype.credentialMatchesFilter = function (entity, filter) {\n    if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {\n      return false;\n    }\n\n    if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {\n      return false;\n    }\n    /*\r\n     * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of \"\"\r\n     * because we don't want a client_credential request to return a cached token that has a homeAccountId\r\n     */\n\n\n    if (typeof filter.homeAccountId === \"string\" && !this.matchHomeAccountId(entity, filter.homeAccountId)) {\n      return false;\n    }\n\n    if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {\n      return false;\n    }\n\n    if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {\n      return false;\n    }\n\n    if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {\n      return false;\n    }\n\n    if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {\n      return false;\n    }\n    /*\r\n     * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n     * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n     */\n\n\n    if (!!filter.target && !this.matchTarget(entity, filter.target)) {\n      return false;\n    } // If request OR cached entity has requested Claims Hash, check if they match\n\n\n    if (filter.requestedClaimsHash || entity.requestedClaimsHash) {\n      // Don't match if either is undefined or they are different\n      if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {\n        return false;\n      }\n    } // Access Token with Auth Scheme specific matching\n\n\n    if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\n      if (!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {\n        return false;\n      } // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\n\n\n      if (filter.tokenType === AuthenticationScheme.SSH) {\n        if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n   * @param filter\r\n   */\n\n\n  CacheManager.prototype.getAppMetadataFilteredBy = function (filter) {\n    return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);\n  };\n  /**\r\n   * Support function to help match appMetadata\r\n   * @param environment\r\n   * @param clientId\r\n   */\n\n\n  CacheManager.prototype.getAppMetadataFilteredByInternal = function (environment, clientId) {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    var matchingAppMetadata = {};\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-appMetadata type cache entities\n      if (!_this.isAppMetadata(cacheKey)) {\n        return;\n      } // Attempt retrieval\n\n\n      var entity = _this.getAppMetadata(cacheKey);\n\n      if (!entity) {\n        return;\n      }\n\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n\n      if (!!clientId && !_this.matchClientId(entity, clientId)) {\n        return;\n      }\n\n      matchingAppMetadata[cacheKey] = entity;\n    });\n    return matchingAppMetadata;\n  };\n  /**\r\n   * retrieve authorityMetadata that contains a matching alias\r\n   * @param filter\r\n   */\n\n\n  CacheManager.prototype.getAuthorityMetadataByAlias = function (host) {\n    var _this = this;\n\n    var allCacheKeys = this.getAuthorityMetadataKeys();\n    var matchedEntity = null;\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-authorityMetadata type cache entities\n      if (!_this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(_this.clientId) === -1) {\n        return;\n      } // Attempt retrieval\n\n\n      var entity = _this.getAuthorityMetadata(cacheKey);\n\n      if (!entity) {\n        return;\n      }\n\n      if (entity.aliases.indexOf(host) === -1) {\n        return;\n      }\n\n      matchedEntity = entity;\n    });\n    return matchedEntity;\n  };\n  /**\r\n   * Removes all accounts and related tokens from cache.\r\n   */\n\n\n  CacheManager.prototype.removeAllAccounts = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var allAccountKeys, removedAccounts;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            allAccountKeys = this.getAccountKeys();\n            removedAccounts = [];\n            allAccountKeys.forEach(function (cacheKey) {\n              removedAccounts.push(_this.removeAccount(cacheKey));\n            });\n            return [4\n            /*yield*/\n            , Promise.all(removedAccounts)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes the account and related tokens for a given account key\r\n   * @param account\r\n   */\n\n\n  CacheManager.prototype.removeAccount = function (accountKey) {\n    return __awaiter(this, void 0, void 0, function () {\n      var account;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            account = this.getAccount(accountKey);\n\n            if (!account) {\n              throw ClientAuthError.createNoAccountFoundError();\n            }\n\n            return [4\n            /*yield*/\n            , this.removeAccountContext(account)];\n\n          case 1:\n            _a.sent();\n\n            this.removeItem(accountKey);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes credentials associated with the provided account\r\n   * @param account\r\n   */\n\n\n  CacheManager.prototype.removeAccountContext = function (account) {\n    return __awaiter(this, void 0, void 0, function () {\n      var allTokenKeys, accountId, removedCredentials;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            allTokenKeys = this.getTokenKeys();\n            accountId = account.generateAccountId();\n            removedCredentials = [];\n            allTokenKeys.idToken.forEach(function (key) {\n              if (key.indexOf(accountId) === 0) {\n                _this.removeIdToken(key);\n              }\n            });\n            allTokenKeys.accessToken.forEach(function (key) {\n              if (key.indexOf(accountId) === 0) {\n                removedCredentials.push(_this.removeAccessToken(key));\n              }\n            });\n            allTokenKeys.refreshToken.forEach(function (key) {\n              if (key.indexOf(accountId) === 0) {\n                _this.removeRefreshToken(key);\n              }\n            });\n            return [4\n            /*yield*/\n            , Promise.all(removedCredentials)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * returns a boolean if the given credential is removed\r\n   * @param credential\r\n   */\n\n\n  CacheManager.prototype.removeAccessToken = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var credential, accessTokenWithAuthSchemeEntity, kid;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            credential = this.getAccessTokenCredential(key);\n\n            if (!credential) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            if (!(credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase())) return [3\n            /*break*/\n            , 4];\n            if (!(credential.tokenType === AuthenticationScheme.POP)) return [3\n            /*break*/\n            , 4];\n            accessTokenWithAuthSchemeEntity = credential;\n            kid = accessTokenWithAuthSchemeEntity.keyId;\n            if (!kid) return [3\n            /*break*/\n            , 4];\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.cryptoImpl.removeTokenBindingKey(kid)];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            _a.sent();\n\n            throw ClientAuthError.createBindingKeyNotRemovedError();\n\n          case 4:\n            return [2\n            /*return*/\n            , this.removeItem(key)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes all app metadata objects from cache.\r\n   */\n\n\n  CacheManager.prototype.removeAppMetadata = function () {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    allCacheKeys.forEach(function (cacheKey) {\n      if (_this.isAppMetadata(cacheKey)) {\n        _this.removeItem(cacheKey);\n      }\n    });\n    return true;\n  };\n  /**\r\n   * Retrieve the cached credentials into a cacherecord\r\n   * @param account\r\n   * @param clientId\r\n   * @param scopes\r\n   * @param environment\r\n   * @param authScheme\r\n   */\n\n\n  CacheManager.prototype.readCacheRecord = function (account, request, environment) {\n    var tokenKeys = this.getTokenKeys();\n    var cachedAccount = this.readAccountFromCache(account);\n    var cachedIdToken = this.getIdToken(account, tokenKeys);\n    var cachedAccessToken = this.getAccessToken(account, request, tokenKeys);\n    var cachedRefreshToken = this.getRefreshToken(account, false, tokenKeys);\n    var cachedAppMetadata = this.readAppMetadataFromCache(environment);\n\n    if (cachedAccount && cachedIdToken) {\n      cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;\n    }\n\n    return {\n      account: cachedAccount,\n      idToken: cachedIdToken,\n      accessToken: cachedAccessToken,\n      refreshToken: cachedRefreshToken,\n      appMetadata: cachedAppMetadata\n    };\n  };\n  /**\r\n   * Retrieve AccountEntity from cache\r\n   * @param account\r\n   */\n\n\n  CacheManager.prototype.readAccountFromCache = function (account) {\n    var accountKey = AccountEntity.generateAccountCacheKey(account);\n    return this.getAccount(accountKey);\n  };\n  /**\r\n   * Retrieve IdTokenEntity from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param inputRealm\r\n   */\n\n\n  CacheManager.prototype.getIdToken = function (account, tokenKeys) {\n    this.commonLogger.trace(\"CacheManager - getIdToken called\");\n    var idTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.ID_TOKEN,\n      clientId: this.clientId,\n      realm: account.tenantId\n    };\n    var idTokens = this.getIdTokensByFilter(idTokenFilter, tokenKeys);\n    var numIdTokens = idTokens.length;\n\n    if (numIdTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getIdToken - No token found\");\n      return null;\n    } else if (numIdTokens > 1) {\n      throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n    }\n\n    this.commonLogger.info(\"CacheManager:getIdToken - Returning id token\");\n    return idTokens[0];\n  };\n  /**\r\n   * Gets all idTokens matching the given filter\r\n   * @param filter\r\n   * @returns\r\n   */\n\n\n  CacheManager.prototype.getIdTokensByFilter = function (filter, tokenKeys) {\n    var _this = this;\n\n    var idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;\n    var idTokens = [];\n    idTokenKeys.forEach(function (key) {\n      if (!_this.idTokenKeyMatchesFilter(key, __assign({\n        clientId: _this.clientId\n      }, filter))) {\n        return;\n      }\n\n      var idToken = _this.getIdTokenCredential(key);\n\n      if (idToken && _this.credentialMatchesFilter(idToken, filter)) {\n        idTokens.push(idToken);\n      }\n    });\n    return idTokens;\n  };\n  /**\r\n   * Validate the cache key against filter before retrieving and parsing cache value\r\n   * @param key\r\n   * @param filter\r\n   * @returns\r\n   */\n\n\n  CacheManager.prototype.idTokenKeyMatchesFilter = function (inputKey, filter) {\n    var key = inputKey.toLowerCase();\n\n    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Removes idToken from the cache\r\n   * @param key\r\n   */\n\n\n  CacheManager.prototype.removeIdToken = function (key) {\n    this.removeItem(key);\n  };\n  /**\r\n   * Removes refresh token from the cache\r\n   * @param key\r\n   */\n\n\n  CacheManager.prototype.removeRefreshToken = function (key) {\n    this.removeItem(key);\n  };\n  /**\r\n   * Retrieve AccessTokenEntity from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param scopes\r\n   * @param authScheme\r\n   */\n\n\n  CacheManager.prototype.getAccessToken = function (account, request, tokenKeys) {\n    var _this = this;\n\n    this.commonLogger.trace(\"CacheManager - getAccessToken called\");\n    var scopes = ScopeSet.createSearchScopes(request.scopes);\n    var authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n    /*\r\n     * Distinguish between Bearer and PoP/SSH token cache types\r\n     * Cast to lowercase to handle \"bearer\" from ADFS\r\n     */\n\n    var credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n    var accessTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: credentialType,\n      clientId: this.clientId,\n      realm: account.tenantId,\n      target: scopes,\n      tokenType: authScheme,\n      keyId: request.sshKid,\n      requestedClaimsHash: request.requestedClaimsHash\n    };\n    var accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;\n    var accessTokens = [];\n    accessTokenKeys.forEach(function (key) {\n      // Validate key\n      if (_this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {\n        var accessToken = _this.getAccessTokenCredential(key); // Validate value\n\n\n        if (accessToken && _this.credentialMatchesFilter(accessToken, accessTokenFilter)) {\n          accessTokens.push(accessToken);\n        }\n      }\n    });\n    var numAccessTokens = accessTokens.length;\n\n    if (numAccessTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getAccessToken - No token found\");\n      return null;\n    } else if (numAccessTokens > 1) {\n      throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n    }\n\n    this.commonLogger.info(\"CacheManager:getAccessToken - Returning access token\");\n    return accessTokens[0];\n  };\n  /**\r\n   * Validate the cache key against filter before retrieving and parsing cache value\r\n   * @param key\r\n   * @param filter\r\n   * @param keyMustContainAllScopes\r\n   * @returns\r\n   */\n\n\n  CacheManager.prototype.accessTokenKeyMatchesFilter = function (inputKey, filter, keyMustContainAllScopes) {\n    var key = inputKey.toLowerCase();\n\n    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n\n    if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {\n      return false;\n    }\n\n    if (filter.requestedClaimsHash && key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {\n      return false;\n    }\n\n    if (filter.target) {\n      var scopes = filter.target.asArray();\n\n      for (var i = 0; i < scopes.length; i++) {\n        if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {\n          // When performing a cache lookup a missing scope would be a cache miss\n          return false;\n        } else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {\n          // When performing a cache write, any token with a subset of requested scopes should be replaced\n          return true;\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Gets all access tokens matching the filter\r\n   * @param filter\r\n   * @returns\r\n   */\n\n\n  CacheManager.prototype.getAccessTokensByFilter = function (filter) {\n    var _this = this;\n\n    var tokenKeys = this.getTokenKeys();\n    var accessTokens = [];\n    tokenKeys.accessToken.forEach(function (key) {\n      if (!_this.accessTokenKeyMatchesFilter(key, filter, true)) {\n        return;\n      }\n\n      var accessToken = _this.getAccessTokenCredential(key);\n\n      if (accessToken && _this.credentialMatchesFilter(accessToken, filter)) {\n        accessTokens.push(accessToken);\n      }\n    });\n    return accessTokens;\n  };\n  /**\r\n   * Helper to retrieve the appropriate refresh token from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param familyRT\r\n   */\n\n\n  CacheManager.prototype.getRefreshToken = function (account, familyRT, tokenKeys) {\n    var _this = this;\n\n    this.commonLogger.trace(\"CacheManager - getRefreshToken called\");\n    var id = familyRT ? THE_FAMILY_ID : undefined;\n    var refreshTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.REFRESH_TOKEN,\n      clientId: this.clientId,\n      familyId: id\n    };\n    var refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;\n    var refreshTokens = [];\n    refreshTokenKeys.forEach(function (key) {\n      // Validate key\n      if (_this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {\n        var refreshToken = _this.getRefreshTokenCredential(key); // Validate value\n\n\n        if (refreshToken && _this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {\n          refreshTokens.push(refreshToken);\n        }\n      }\n    });\n    var numRefreshTokens = refreshTokens.length;\n\n    if (numRefreshTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getRefreshToken - No refresh token found.\");\n      return null;\n    } // address the else case after remove functions address environment aliases\n\n\n    this.commonLogger.info(\"CacheManager:getRefreshToken - returning refresh token\");\n    return refreshTokens[0];\n  };\n  /**\r\n   * Validate the cache key against filter before retrieving and parsing cache value\r\n   * @param key\r\n   * @param filter\r\n   */\n\n\n  CacheManager.prototype.refreshTokenKeyMatchesFilter = function (inputKey, filter) {\n    var key = inputKey.toLowerCase();\n\n    if (filter.familyId && key.indexOf(filter.familyId.toLowerCase()) === -1) {\n      return false;\n    } // If familyId is used, clientId is not in the key\n\n\n    if (!filter.familyId && filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Retrieve AppMetadataEntity from cache\r\n   */\n\n\n  CacheManager.prototype.readAppMetadataFromCache = function (environment) {\n    var appMetadataFilter = {\n      environment: environment,\n      clientId: this.clientId\n    };\n    var appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);\n    var appMetadataEntries = Object.keys(appMetadata).map(function (key) {\n      return appMetadata[key];\n    });\n    var numAppMetadata = appMetadataEntries.length;\n\n    if (numAppMetadata < 1) {\n      return null;\n    } else if (numAppMetadata > 1) {\n      throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\n    }\n\n    return appMetadataEntries[0];\n  };\n  /**\r\n   * Return the family_id value associated  with FOCI\r\n   * @param environment\r\n   * @param clientId\r\n   */\n\n\n  CacheManager.prototype.isAppMetadataFOCI = function (environment) {\n    var appMetadata = this.readAppMetadataFromCache(environment);\n    return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n  };\n  /**\r\n   * helper to match account ids\r\n   * @param value\r\n   * @param homeAccountId\r\n   */\n\n\n  CacheManager.prototype.matchHomeAccountId = function (entity, homeAccountId) {\n    return !!(typeof entity.homeAccountId === \"string\" && homeAccountId === entity.homeAccountId);\n  };\n  /**\r\n   * helper to match account ids\r\n   * @param entity\r\n   * @param localAccountId\r\n   * @returns\r\n   */\n\n\n  CacheManager.prototype.matchLocalAccountId = function (entity, localAccountId) {\n    return !!(typeof entity.localAccountId === \"string\" && localAccountId === entity.localAccountId);\n  };\n  /**\r\n   * helper to match usernames\r\n   * @param entity\r\n   * @param username\r\n   * @returns\r\n   */\n\n\n  CacheManager.prototype.matchUsername = function (entity, username) {\n    return !!(typeof entity.username === \"string\" && username.toLowerCase() === entity.username.toLowerCase());\n  };\n  /**\r\n   * helper to match assertion\r\n   * @param value\r\n   * @param oboAssertion\r\n   */\n\n\n  CacheManager.prototype.matchUserAssertionHash = function (entity, userAssertionHash) {\n    return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);\n  };\n  /**\r\n   * helper to match environment\r\n   * @param value\r\n   * @param environment\r\n   */\n\n\n  CacheManager.prototype.matchEnvironment = function (entity, environment) {\n    var cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n\n    if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * helper to match credential type\r\n   * @param entity\r\n   * @param credentialType\r\n   */\n\n\n  CacheManager.prototype.matchCredentialType = function (entity, credentialType) {\n    return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();\n  };\n  /**\r\n   * helper to match client ids\r\n   * @param entity\r\n   * @param clientId\r\n   */\n\n\n  CacheManager.prototype.matchClientId = function (entity, clientId) {\n    return !!(entity.clientId && clientId === entity.clientId);\n  };\n  /**\r\n   * helper to match family ids\r\n   * @param entity\r\n   * @param familyId\r\n   */\n\n\n  CacheManager.prototype.matchFamilyId = function (entity, familyId) {\n    return !!(entity.familyId && familyId === entity.familyId);\n  };\n  /**\r\n   * helper to match realm\r\n   * @param entity\r\n   * @param realm\r\n   */\n\n\n  CacheManager.prototype.matchRealm = function (entity, realm) {\n    return !!(entity.realm && realm === entity.realm);\n  };\n  /**\r\n   * helper to match nativeAccountId\r\n   * @param entity\r\n   * @param nativeAccountId\r\n   * @returns boolean indicating the match result\r\n   */\n\n\n  CacheManager.prototype.matchNativeAccountId = function (entity, nativeAccountId) {\n    return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\n  };\n  /**\r\n   * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n   * @param entity\r\n   * @param target\r\n   */\n\n\n  CacheManager.prototype.matchTarget = function (entity, target) {\n    var isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n\n    if (isNotAccessTokenCredential || !entity.target) {\n      return false;\n    }\n\n    var entityScopeSet = ScopeSet.fromString(entity.target);\n    return entityScopeSet.containsScopeSet(target);\n  };\n  /**\r\n   * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\r\n   * @param entity\r\n   * @param tokenType\r\n   */\n\n\n  CacheManager.prototype.matchTokenType = function (entity, tokenType) {\n    return !!(entity.tokenType && entity.tokenType === tokenType);\n  };\n  /**\r\n   * Returns true if the credential's keyId matches the one in the request, false otherwise\r\n   * @param entity\r\n   * @param tokenType\r\n   */\n\n\n  CacheManager.prototype.matchKeyId = function (entity, keyId) {\n    return !!(entity.keyId && entity.keyId === keyId);\n  };\n  /**\r\n   * returns if a given cache entity is of the type appmetadata\r\n   * @param key\r\n   */\n\n\n  CacheManager.prototype.isAppMetadata = function (key) {\n    return key.indexOf(APP_METADATA) !== -1;\n  };\n  /**\r\n   * returns if a given cache entity is of the type authoritymetadata\r\n   * @param key\r\n   */\n\n\n  CacheManager.prototype.isAuthorityMetadata = function (key) {\n    return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n  };\n  /**\r\n   * returns cache key used for cloud instance metadata\r\n   */\n\n\n  CacheManager.prototype.generateAuthorityMetadataCacheKey = function (authority) {\n    return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + \"-\" + this.clientId + \"-\" + authority;\n  };\n  /**\r\n   * Helper to convert serialized data to object\r\n   * @param obj\r\n   * @param json\r\n   */\n\n\n  CacheManager.toObject = function (obj, json) {\n    for (var propertyName in json) {\n      obj[propertyName] = json[propertyName];\n    }\n\n    return obj;\n  };\n\n  return CacheManager;\n}();\n\nvar DefaultStorageClass =\n/** @class */\nfunction (_super) {\n  __extends(DefaultStorageClass, _super);\n\n  function DefaultStorageClass() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DefaultStorageClass.prototype.setAccount = function () {\n    var notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAccount = function () {\n    var notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setIdTokenCredential = function () {\n    var notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getIdTokenCredential = function () {\n    var notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setAccessTokenCredential = function () {\n    var notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAccessTokenCredential = function () {\n    var notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setRefreshTokenCredential = function () {\n    var notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getRefreshTokenCredential = function () {\n    var notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setAppMetadata = function () {\n    var notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAppMetadata = function () {\n    var notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setServerTelemetry = function () {\n    var notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getServerTelemetry = function () {\n    var notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setAuthorityMetadata = function () {\n    var notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAuthorityMetadata = function () {\n    var notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAuthorityMetadataKeys = function () {\n    var notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setThrottlingCache = function () {\n    var notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getThrottlingCache = function () {\n    var notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.removeItem = function () {\n    var notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.containsKey = function () {\n    var notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getKeys = function () {\n    var notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAccountKeys = function () {\n    var notImplErr = \"Storage interface - getAccountKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getTokenKeys = function () {\n    var notImplErr = \"Storage interface - getTokenKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var notImplErr;\n      return __generator(this, function (_a) {\n        notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n      });\n    });\n  };\n\n  DefaultStorageClass.prototype.updateCredentialCacheKey = function () {\n    var notImplErr = \"Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  return DefaultStorageClass;\n}(CacheManager);\n\nexport { CacheManager, DefaultStorageClass };","map":{"version":3,"mappings":"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","names":["clientId","cryptoImpl","logger","commonLogger","clone","name","version","CacheManager","_this","allAccountKeys","getAccountKeys","length","accountEntities","reduce","accounts","key","entity","getAccount","push","allAccounts","map","accountEntity","getAccountInfoFromEntity","getAccountInfoFilteredBy","accountFilter","getAccountsFilteredBy","accountInfo","getAccountInfo","idToken","getIdToken","secret","idTokenClaims","AuthToken","claims","saveCacheRecord","cacheRecord","ClientAuthError","createNullOrUndefinedCacheRecord","account","setAccount","setIdTokenCredential","accessToken","saveAccessToken","_a","refreshToken","setRefreshTokenCredential","appMetadata","setAppMetadata","credential","accessTokenFilter","credentialType","environment","homeAccountId","realm","tokenType","requestedClaimsHash","tokenKeys","getTokenKeys","currentScopes","ScopeSet","fromString","target","removedAccessTokens","forEach","accessTokenKeyMatchesFilter","tokenEntity","getAccessTokenCredential","credentialMatchesFilter","tokenScopeSet","intersectingScopeSets","removeAccessToken","Promise","all","setAccessTokenCredential","matchingAccounts","cacheKey","isAccountKey","matchHomeAccountId","localAccountId","matchLocalAccountId","username","matchUsername","matchEnvironment","matchRealm","nativeAccountId","matchNativeAccountId","tenantId","split","Separators","CACHE_KEY_SEPARATOR","toLowerCase","includes","isCredentialKey","lowerCaseKey","indexOf","CredentialType","ID_TOKEN","ACCESS_TOKEN","ACCESS_TOKEN_WITH_AUTH_SCHEME","REFRESH_TOKEN","clientIdValidation","familyIdValidation","THE_FAMILY_ID","filter","matchClientId","userAssertionHash","matchUserAssertionHash","matchCredentialType","familyId","matchFamilyId","matchTarget","matchTokenType","AuthenticationScheme","SSH","keyId","matchKeyId","getAppMetadataFilteredBy","getAppMetadataFilteredByInternal","allCacheKeys","getKeys","matchingAppMetadata","isAppMetadata","getAppMetadata","getAuthorityMetadataByAlias","host","getAuthorityMetadataKeys","matchedEntity","isAuthorityMetadata","getAuthorityMetadata","aliases","removedAccounts","removeAccount","accountKey","createNoAccountFoundError","removeAccountContext","removeItem","allTokenKeys","accountId","generateAccountId","removedCredentials","removeIdToken","removeRefreshToken","POP","accessTokenWithAuthSchemeEntity","kid","removeTokenBindingKey","createBindingKeyNotRemovedError","request","cachedAccount","readAccountFromCache","cachedIdToken","cachedAccessToken","getAccessToken","cachedRefreshToken","getRefreshToken","cachedAppMetadata","readAppMetadataFromCache","AccountEntity","generateAccountCacheKey","trace","idTokenFilter","idTokens","getIdTokensByFilter","numIdTokens","info","createMultipleMatchingTokensInCacheError","idTokenKeys","idTokenKeyMatchesFilter","__assign","getIdTokenCredential","inputKey","scopes","createSearchScopes","authScheme","authenticationScheme","BEARER","sshKid","accessTokenKeys","accessTokens","numAccessTokens","keyMustContainAllScopes","asArray","i","getAccessTokensByFilter","familyRT","id","undefined","refreshTokenFilter","refreshTokenKeys","refreshTokens","refreshTokenKeyMatchesFilter","getRefreshTokenCredential","numRefreshTokens","appMetadataFilter","appMetadataEntries","Object","keys","numAppMetadata","createMultipleMatchingAppMetadataInCacheError","isAppMetadataFOCI","cloudMetadata","isNotAccessTokenCredential","entityScopeSet","containsScopeSet","APP_METADATA","AUTHORITY_METADATA_CONSTANTS","CACHE_KEY","generateAuthorityMetadataCacheKey","authority","obj","json","propertyName","__extends","DefaultStorageClass","notImplErr","AuthError","createUnexpectedError"],"sources":["/Users/edwardlee/Downloads/msal-react-demo/node_modules/@azure/msal-common/src/cache/CacheManager.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AccountFilter, CredentialFilter, ValidCredentialType, AppMetadataFilter, AppMetadataCache, TokenKeys } from \"./utils/CacheTypes\";\nimport { CacheRecord } from \"./entities/CacheRecord\";\nimport { CredentialType, APP_METADATA, THE_FAMILY_ID, AUTHORITY_METADATA_CONSTANTS, AuthenticationScheme, Separators } from \"../utils/Constants\";\nimport { CredentialEntity } from \"./entities/CredentialEntity\";\nimport { ScopeSet } from \"../request/ScopeSet\";\nimport { AccountEntity } from \"./entities/AccountEntity\";\nimport { AccessTokenEntity } from \"./entities/AccessTokenEntity\";\nimport { IdTokenEntity } from \"./entities/IdTokenEntity\";\nimport { RefreshTokenEntity } from \"./entities/RefreshTokenEntity\";\nimport { AuthError } from \"../error/AuthError\";\nimport { ICacheManager } from \"./interface/ICacheManager\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\nimport { AccountInfo } from \"../account/AccountInfo\";\nimport { AppMetadataEntity } from \"./entities/AppMetadataEntity\";\nimport { ServerTelemetryEntity } from \"./entities/ServerTelemetryEntity\";\nimport { ThrottlingEntity } from \"./entities/ThrottlingEntity\";\nimport { AuthToken } from \"../account/AuthToken\";\nimport { ICrypto } from \"../crypto/ICrypto\";\nimport { AuthorityMetadataEntity } from \"./entities/AuthorityMetadataEntity\";\nimport { BaseAuthRequest } from \"../request/BaseAuthRequest\";\nimport { Logger } from \"../logger/Logger\";\nimport { name, version } from \"../packageMetadata\";\n\n/**\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\n */\nexport abstract class CacheManager implements ICacheManager {\n    protected clientId: string;\n    protected cryptoImpl: ICrypto;\n    // Instance of logger for functions defined in the msal-common layer\n    private commonLogger: Logger;\n\n    constructor(clientId: string, cryptoImpl: ICrypto, logger: Logger) {\n        this.clientId = clientId;\n        this.cryptoImpl = cryptoImpl;\n        this.commonLogger = logger.clone(name, version);\n    }\n\n    /**\n     * fetch the account entity from the platform cache\n     *  @param accountKey\n     */\n    abstract getAccount(accountKey: string): AccountEntity | null;\n\n    /**\n     * set account entity in the platform cache\n     * @param account\n     */\n    abstract setAccount(account: AccountEntity): void;\n\n    /**\n     * fetch the idToken entity from the platform cache\n     * @param idTokenKey\n     */\n    abstract getIdTokenCredential(idTokenKey: string): IdTokenEntity | null;\n\n    /**\n     * set idToken entity to the platform cache\n     * @param idToken\n     */\n    abstract setIdTokenCredential(idToken: IdTokenEntity): void;\n\n    /**\n     * fetch the idToken entity from the platform cache\n     * @param accessTokenKey\n     */\n    abstract getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null;\n\n    /**\n     * set idToken entity to the platform cache\n     * @param accessToken\n     */\n    abstract setAccessTokenCredential(accessToken: AccessTokenEntity): void;\n\n    /**\n     * fetch the idToken entity from the platform cache\n     * @param refreshTokenKey\n     */\n    abstract getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null;\n\n    /**\n     * set idToken entity to the platform cache\n     * @param refreshToken\n     */\n    abstract setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void;\n\n    /**\n     * fetch appMetadata entity from the platform cache\n     * @param appMetadataKey\n     */\n    abstract getAppMetadata(appMetadataKey: string): AppMetadataEntity | null;\n\n    /**\n     * set appMetadata entity to the platform cache\n     * @param appMetadata\n     */\n    abstract setAppMetadata(appMetadata: AppMetadataEntity): void;\n\n    /**\n     * fetch server telemetry entity from the platform cache\n     * @param serverTelemetryKey\n     */\n    abstract getServerTelemetry(serverTelemetryKey: string): ServerTelemetryEntity | null;\n\n    /**\n     * set server telemetry entity to the platform cache\n     * @param serverTelemetryKey\n     * @param serverTelemetry\n     */\n    abstract setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void;\n\n    /**\n     * fetch cloud discovery metadata entity from the platform cache\n     * @param key\n     */\n    abstract getAuthorityMetadata(key: string): AuthorityMetadataEntity | null;\n\n    /**\n     *\n     */\n    abstract getAuthorityMetadataKeys(): Array<string>;\n\n    /**\n     * set cloud discovery metadata entity to the platform cache\n     * @param key\n     * @param value\n     */\n    abstract setAuthorityMetadata(key: string, value: AuthorityMetadataEntity): void;\n\n    /**\n     * fetch throttling entity from the platform cache\n     * @param throttlingCacheKey\n     */\n    abstract getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null;\n\n    /**\n     * set throttling entity to the platform cache\n     * @param throttlingCacheKey\n     * @param throttlingCache\n     */\n    abstract setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void;\n\n    /**\n     * Function to remove an item from cache given its key.\n     * @param key\n     */\n    abstract removeItem(key: string): void;\n\n    /**\n     * Function which returns boolean whether cache contains a specific key.\n     * @param key\n     */\n    abstract containsKey(key: string, type?: string): boolean;\n\n    /**\n     * Function which retrieves all current keys from the cache.\n     */\n    abstract getKeys(): string[];\n\n    /**\n     * Function which retrieves all account keys from the cache\n     */\n    abstract getAccountKeys(): string[];\n\n    /**\n     * Function which retrieves all token keys from the cache\n     */\n    abstract getTokenKeys(): TokenKeys;\n\n    /**\n     * Function which clears cache.\n     */\n    abstract clear(): Promise<void>;\n\n    /**\n     * Function which updates an outdated credential cache key\n     */\n    abstract updateCredentialCacheKey(currentCacheKey: string, credential: ValidCredentialType): string;\n\n    /**\n     * Returns all accounts in cache\n     */\n    getAllAccounts(): AccountInfo[] {\n        const allAccountKeys = this.getAccountKeys();\n        if (allAccountKeys.length < 1) {\n            return [];\n        }\n\n        const accountEntities: AccountEntity[] = allAccountKeys.reduce((accounts: AccountEntity[], key: string) => {\n            const entity: AccountEntity | null = this.getAccount(key);\n\n            if (!entity) {\n                return accounts;\n            }\n            accounts.push(entity);\n            return accounts;\n        }, []);\n\n        if (accountEntities.length < 1) {\n            return [];\n        } else {\n            const allAccounts = accountEntities.map<AccountInfo>((accountEntity) => {\n                return this.getAccountInfoFromEntity(accountEntity);\n            });\n            return allAccounts;\n        }\n    }\n\n    /** \n     * Gets accountInfo object based on provided filters\n     */\n    getAccountInfoFilteredBy(accountFilter: AccountFilter): AccountInfo | null{\n        const allAccounts = this.getAccountsFilteredBy(accountFilter);\n        if (allAccounts.length > 0) {\n            return this.getAccountInfoFromEntity(allAccounts[0]);\n        } else {\n            return null;\n        }\n    }\n\n    private getAccountInfoFromEntity(accountEntity: AccountEntity): AccountInfo {\n        const accountInfo = accountEntity.getAccountInfo();\n        const idToken = this.getIdToken(accountInfo);\n        if (idToken) {\n            accountInfo.idToken = idToken.secret;\n            accountInfo.idTokenClaims = new AuthToken(idToken.secret, this.cryptoImpl).claims;\n        }\n        return accountInfo;\n    }\n\n    /**\n     * saves a cache record\n     * @param cacheRecord\n     */\n    async saveCacheRecord(cacheRecord: CacheRecord): Promise<void> {\n        if (!cacheRecord) {\n            throw ClientAuthError.createNullOrUndefinedCacheRecord();\n        }\n\n        if (!!cacheRecord.account) {\n            this.setAccount(cacheRecord.account);\n        }\n\n        if (!!cacheRecord.idToken) {\n            this.setIdTokenCredential(cacheRecord.idToken);\n        }\n\n        if (!!cacheRecord.accessToken) {\n            await this.saveAccessToken(cacheRecord.accessToken);\n        }\n\n        if (!!cacheRecord.refreshToken) {\n            this.setRefreshTokenCredential(cacheRecord.refreshToken);\n        }\n\n        if (!!cacheRecord.appMetadata) {\n            this.setAppMetadata(cacheRecord.appMetadata);\n        }\n    }\n\n    /**\n     * saves access token credential\n     * @param credential\n     */\n    private async saveAccessToken(credential: AccessTokenEntity): Promise<void> {\n        const accessTokenFilter: CredentialFilter = {\n            clientId: credential.clientId,\n            credentialType: credential.credentialType,\n            environment: credential.environment,\n            homeAccountId: credential.homeAccountId,\n            realm: credential.realm,\n            tokenType: credential.tokenType,\n            requestedClaimsHash: credential.requestedClaimsHash\n        };\n\n        const tokenKeys = this.getTokenKeys();\n        const currentScopes = ScopeSet.fromString(credential.target);\n\n        const removedAccessTokens: Array<Promise<void>> = [];\n        tokenKeys.accessToken.forEach((key) => {\n            if(!this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {\n                return;\n            }\n            \n            const tokenEntity = this.getAccessTokenCredential(key);\n\n            if (tokenEntity && this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {\n                const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n                    removedAccessTokens.push(this.removeAccessToken(key));\n                }\n            }\n        });\n        await Promise.all(removedAccessTokens);\n        this.setAccessTokenCredential(credential);\n    }\n\n    /**\n     * retrieve accounts matching all provided filters; if no filter is set, get all accounts\n     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\n     * @param homeAccountId\n     * @param environment\n     * @param realm\n     */\n    getAccountsFilteredBy(accountFilter: AccountFilter): AccountEntity[] {\n        const allAccountKeys = this.getAccountKeys();\n        const matchingAccounts: AccountEntity[] = [];\n\n        allAccountKeys.forEach((cacheKey) => {\n            if (!this.isAccountKey(cacheKey, accountFilter.homeAccountId, accountFilter.realm)) {\n                // Don't parse value if the key doesn't match the account filters\n                return;\n            }\n\n            const entity: AccountEntity | null = this.getAccount(cacheKey);\n\n            if (!entity) {\n                return;\n            }\n\n            if (!!accountFilter.homeAccountId && !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {\n                return;\n            }\n\n            if (!!accountFilter.localAccountId && !this.matchLocalAccountId(entity, accountFilter.localAccountId)) {\n                return;\n            }\n\n            if (!!accountFilter.username && !this.matchUsername(entity, accountFilter.username)) {\n                return;\n            }\n\n            if (!!accountFilter.environment && !this.matchEnvironment(entity, accountFilter.environment)) {\n                return;\n            }\n\n            if (!!accountFilter.realm && !this.matchRealm(entity, accountFilter.realm)) {\n                return;\n            }\n\n            if (!!accountFilter.nativeAccountId && !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {\n                return;\n            }\n\n            matchingAccounts.push(entity);\n        });\n\n        return matchingAccounts;\n    }\n\n    /**\n     * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided\n     * @param key \n     * @param homeAccountId \n     * @param tenantId \n     * @returns \n     */\n    isAccountKey(key: string, homeAccountId?: string, tenantId?: string): boolean {\n        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {\n            // Account cache keys contain 3 items separated by '-' (each item may also contain '-')\n            return false;\n        }\n\n        if (homeAccountId && !key.toLowerCase().includes(homeAccountId.toLowerCase())) {\n            return false;\n        }\n\n        if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {\n            return false;\n        }\n\n        // Do not check environment as aliasing can cause false negatives\n\n        return true;\n    }\n\n    /**\n     * Returns true if the given key matches our credential key schema.\n     * @param key \n     */\n    isCredentialKey(key: string): boolean {\n        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {\n            // Credential cache keys contain 6 items separated by '-' (each item may also contain '-')\n            return false;\n        }\n\n        const lowerCaseKey = key.toLowerCase();\n        // Credential keys must indicate what credential type they represent\n        if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) === -1 &&\n            lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) === -1 &&\n            lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 &&\n            lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) === -1\n        ) {\n            return false;\n        }\n\n        if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) > -1) {\n            // Refresh tokens must contain the client id or family id\n            const clientIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${this.clientId}${Separators.CACHE_KEY_SEPARATOR}`;\n            const familyIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${THE_FAMILY_ID}${Separators.CACHE_KEY_SEPARATOR}`;\n            if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 && lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {\n                return false;\n            }\n        } else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {\n            // Tokens must contain the clientId\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns whether or not the given credential entity matches the filter\n     * @param entity \n     * @param filter \n     * @returns \n     */\n    credentialMatchesFilter(entity: ValidCredentialType, filter: CredentialFilter): boolean {\n        if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {\n            return false;\n        }\n\n        if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {\n            return false;\n        }\n\n        /*\n         * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of \"\"\n         * because we don't want a client_credential request to return a cached token that has a homeAccountId\n         */\n        if ((typeof filter.homeAccountId === \"string\") && !this.matchHomeAccountId(entity, filter.homeAccountId)) {\n            return false;\n        }\n\n        if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {\n            return false;\n        }\n\n        if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {\n            return false;\n        }\n\n        if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {\n            return false;\n        }\n\n        if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {\n            return false;\n        }\n\n        /*\n         * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\n         * Resource specific refresh tokens case will be added when the support is deemed necessary\n         */\n        if (!!filter.target && !this.matchTarget(entity, filter.target)) {\n            return false;\n        }\n\n        // If request OR cached entity has requested Claims Hash, check if they match\n        if (filter.requestedClaimsHash || entity.requestedClaimsHash) {\n            // Don't match if either is undefined or they are different\n            if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {\n                return false;\n            }\n        }\n\n        // Access Token with Auth Scheme specific matching\n        if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\n            if(!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {\n                return false;\n            }\n\n            // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\n            if (filter.tokenType === AuthenticationScheme.SSH) {\n                if(filter.keyId && !this.matchKeyId(entity, filter.keyId)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\n     * @param filter\n     */\n    getAppMetadataFilteredBy(filter: AppMetadataFilter): AppMetadataCache {\n        return this.getAppMetadataFilteredByInternal(\n            filter.environment,\n            filter.clientId,\n        );\n    }\n\n    /**\n     * Support function to help match appMetadata\n     * @param environment\n     * @param clientId\n     */\n    private getAppMetadataFilteredByInternal(\n        environment?: string,\n        clientId?: string\n    ): AppMetadataCache {\n\n        const allCacheKeys = this.getKeys();\n        const matchingAppMetadata: AppMetadataCache = {};\n\n        allCacheKeys.forEach((cacheKey) => {\n            // don't parse any non-appMetadata type cache entities\n            if (!this.isAppMetadata(cacheKey)) {\n                return;\n            }\n\n            // Attempt retrieval\n            const entity = this.getAppMetadata(cacheKey);\n\n            if (!entity) {\n                return;\n            }\n\n            if (!!environment && !this.matchEnvironment(entity, environment)) {\n                return;\n            }\n\n            if (!!clientId && !this.matchClientId(entity, clientId)) {\n                return;\n            }\n\n            matchingAppMetadata[cacheKey] = entity;\n\n        });\n\n        return matchingAppMetadata;\n    }\n\n    /**\n     * retrieve authorityMetadata that contains a matching alias\n     * @param filter\n     */\n    getAuthorityMetadataByAlias(host: string): AuthorityMetadataEntity | null {\n        const allCacheKeys = this.getAuthorityMetadataKeys();\n        let matchedEntity = null;\n\n        allCacheKeys.forEach((cacheKey) => {\n            // don't parse any non-authorityMetadata type cache entities\n            if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {\n                return;\n            }\n\n            // Attempt retrieval\n            const entity = this.getAuthorityMetadata(cacheKey);\n\n            if (!entity) {\n                return;\n            }\n\n            if (entity.aliases.indexOf(host) === -1) {\n                return;\n            }\n\n            matchedEntity = entity;\n\n        });\n\n        return matchedEntity;\n    }\n\n    /**\n     * Removes all accounts and related tokens from cache.\n     */\n    async removeAllAccounts(): Promise<void> {\n        const allAccountKeys = this.getAccountKeys();\n        const removedAccounts: Array<Promise<void>> = [];\n\n        allAccountKeys.forEach((cacheKey) => {\n            removedAccounts.push(this.removeAccount(cacheKey));\n        });\n\n        await Promise.all(removedAccounts);\n    }\n\n    /**\n     * Removes the account and related tokens for a given account key\n     * @param account\n     */\n    async removeAccount(accountKey: string): Promise<void> {\n        const account = this.getAccount(accountKey);\n        if (!account) {\n            throw ClientAuthError.createNoAccountFoundError();\n        }\n        await this.removeAccountContext(account);\n        this.removeItem(accountKey);\n    }\n\n    /**\n     * Removes credentials associated with the provided account\n     * @param account\n     */\n    async removeAccountContext(account: AccountEntity): Promise<void> {\n        const allTokenKeys = this.getTokenKeys();\n        const accountId = account.generateAccountId();\n        const removedCredentials: Array<Promise<void>> = [];\n\n        allTokenKeys.idToken.forEach((key) => {\n            if (key.indexOf(accountId) === 0) {\n                this.removeIdToken(key);\n            }\n        });\n\n        allTokenKeys.accessToken.forEach((key) => {\n            if (key.indexOf(accountId) === 0) {\n                removedCredentials.push(this.removeAccessToken(key));\n            }\n        });\n\n        allTokenKeys.refreshToken.forEach((key) => {\n            if (key.indexOf(accountId) === 0) {\n                this.removeRefreshToken(key);\n            }\n        });\n\n        await Promise.all(removedCredentials);\n    }\n\n    /**\n     * returns a boolean if the given credential is removed\n     * @param credential\n     */\n    async removeAccessToken(key: string): Promise<void> {\n        const credential = this.getAccessTokenCredential(key);\n        if (!credential) {\n            return;\n        }\n\n        // Remove Token Binding Key from key store for PoP Tokens Credentials\n        if (credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) {\n            if(credential.tokenType === AuthenticationScheme.POP) {\n                const accessTokenWithAuthSchemeEntity = credential as AccessTokenEntity;\n                const kid = accessTokenWithAuthSchemeEntity.keyId;\n\n                if (kid) {\n                    try {\n                        await this.cryptoImpl.removeTokenBindingKey(kid);\n                    } catch (error) {\n                        throw ClientAuthError.createBindingKeyNotRemovedError();\n                    }\n                }\n            }\n        }\n\n        return this.removeItem(key);\n    }\n\n    /**\n     * Removes all app metadata objects from cache.\n     */\n    removeAppMetadata(): boolean {\n        const allCacheKeys = this.getKeys();\n        allCacheKeys.forEach((cacheKey) => {\n            if (this.isAppMetadata(cacheKey)) {\n                this.removeItem(cacheKey);\n            }\n        });\n\n        return true;\n    }\n\n    /**\n     * Retrieve the cached credentials into a cacherecord\n     * @param account\n     * @param clientId\n     * @param scopes\n     * @param environment\n     * @param authScheme\n     */\n    readCacheRecord(account: AccountInfo, request: BaseAuthRequest, environment: string): CacheRecord {\n        const tokenKeys = this.getTokenKeys();\n        const cachedAccount = this.readAccountFromCache(account);\n        const cachedIdToken = this.getIdToken(account, tokenKeys);\n        const cachedAccessToken = this.getAccessToken(account, request, tokenKeys);\n        const cachedRefreshToken = this.getRefreshToken(account, false, tokenKeys);\n        const cachedAppMetadata = this.readAppMetadataFromCache(environment);\n\n        if (cachedAccount && cachedIdToken) {\n            cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;\n        }\n\n        return {\n            account: cachedAccount,\n            idToken: cachedIdToken,\n            accessToken: cachedAccessToken,\n            refreshToken: cachedRefreshToken,\n            appMetadata: cachedAppMetadata,\n        };\n    }\n\n    /**\n     * Retrieve AccountEntity from cache\n     * @param account\n     */\n    readAccountFromCache(account: AccountInfo): AccountEntity | null {\n        const accountKey: string = AccountEntity.generateAccountCacheKey(account);\n        return this.getAccount(accountKey);\n    }\n\n    /**\n     * Retrieve IdTokenEntity from cache\n     * @param clientId\n     * @param account\n     * @param inputRealm\n     */\n    getIdToken(account: AccountInfo, tokenKeys?: TokenKeys): IdTokenEntity | null {\n        this.commonLogger.trace(\"CacheManager - getIdToken called\");\n        const idTokenFilter: CredentialFilter = {\n            homeAccountId: account.homeAccountId,\n            environment: account.environment,\n            credentialType: CredentialType.ID_TOKEN,\n            clientId: this.clientId,\n            realm: account.tenantId,\n        };\n\n        const idTokens: IdTokenEntity[] = this.getIdTokensByFilter(idTokenFilter, tokenKeys);\n        const numIdTokens = idTokens.length;\n\n        if (numIdTokens < 1) {\n            this.commonLogger.info(\"CacheManager:getIdToken - No token found\");\n            return null;\n        } else if (numIdTokens > 1) {\n            throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n        }\n\n        this.commonLogger.info(\"CacheManager:getIdToken - Returning id token\");\n        return idTokens[0];\n    }\n\n    /**\n     * Gets all idTokens matching the given filter\n     * @param filter \n     * @returns \n     */\n    getIdTokensByFilter(filter: CredentialFilter, tokenKeys?: TokenKeys): IdTokenEntity[] {\n        const idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;\n\n        const idTokens: IdTokenEntity[] = [];\n        idTokenKeys.forEach((key) => {\n            if (!this.idTokenKeyMatchesFilter(key, {clientId: this.clientId, ...filter})) {\n                return;\n            }\n\n            const idToken = this.getIdTokenCredential(key);\n            if (idToken && this.credentialMatchesFilter(idToken, filter)) {\n                idTokens.push(idToken);\n            }\n        });\n\n        return idTokens;\n    }\n\n    /**\n     * Validate the cache key against filter before retrieving and parsing cache value\n     * @param key \n     * @param filter\n     * @returns \n     */\n    idTokenKeyMatchesFilter(inputKey: string, filter: CredentialFilter): boolean {\n        const key = inputKey.toLowerCase();\n        if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n            return false;\n        }\n\n        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Removes idToken from the cache\n     * @param key \n     */\n    removeIdToken(key: string): void {\n        this.removeItem(key);\n    }\n\n    /**\n     * Removes refresh token from the cache\n     * @param key \n     */\n    removeRefreshToken(key: string): void {\n        this.removeItem(key);\n    }\n\n    /**\n     * Retrieve AccessTokenEntity from cache\n     * @param clientId\n     * @param account\n     * @param scopes\n     * @param authScheme\n     */\n    getAccessToken(account: AccountInfo, request: BaseAuthRequest, tokenKeys?: TokenKeys): AccessTokenEntity | null {\n        this.commonLogger.trace(\"CacheManager - getAccessToken called\");\n        const scopes =  ScopeSet.createSearchScopes(request.scopes);\n        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n        /*\n         * Distinguish between Bearer and PoP/SSH token cache types\n         * Cast to lowercase to handle \"bearer\" from ADFS\n         */\n        const credentialType = (authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n\n        const accessTokenFilter: CredentialFilter = {\n            homeAccountId: account.homeAccountId,\n            environment: account.environment,\n            credentialType: credentialType,\n            clientId: this.clientId,\n            realm: account.tenantId,\n            target: scopes,\n            tokenType: authScheme,\n            keyId: request.sshKid,\n            requestedClaimsHash: request.requestedClaimsHash,\n        };\n\n        const accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;\n        const accessTokens: AccessTokenEntity[] = [];\n\n        accessTokenKeys.forEach((key) => {\n            // Validate key\n            if (this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {\n                const accessToken = this.getAccessTokenCredential(key);\n\n                // Validate value\n                if (accessToken && this.credentialMatchesFilter(accessToken, accessTokenFilter)) {\n                    accessTokens.push(accessToken);\n                }\n            }\n        });\n\n        const numAccessTokens = accessTokens.length;\n        if (numAccessTokens < 1) {\n            this.commonLogger.info(\"CacheManager:getAccessToken - No token found\");\n            return null;\n        } else if (numAccessTokens > 1) {\n            throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n        }\n\n        this.commonLogger.info(\"CacheManager:getAccessToken - Returning access token\");\n        return accessTokens[0];\n    }\n\n    /**\n     * Validate the cache key against filter before retrieving and parsing cache value\n     * @param key \n     * @param filter \n     * @param keyMustContainAllScopes \n     * @returns \n     */\n    accessTokenKeyMatchesFilter(inputKey: string, filter: CredentialFilter, keyMustContainAllScopes: boolean): boolean {\n        const key = inputKey.toLowerCase();\n        if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n            return false;\n        }\n\n        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n            return false;\n        }\n\n        if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {\n            return false;\n        }\n\n        if (filter.requestedClaimsHash && key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {\n            return false;\n        }\n\n        if (filter.target) {\n            const scopes = filter.target.asArray();\n            for (let i = 0; i < scopes.length; i++) {\n                if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {\n                    // When performing a cache lookup a missing scope would be a cache miss\n                    return false;\n                } else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {\n                    // When performing a cache write, any token with a subset of requested scopes should be replaced\n                    return true;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Gets all access tokens matching the filter\n     * @param filter \n     * @returns \n     */\n    getAccessTokensByFilter(filter: CredentialFilter): AccessTokenEntity[] {\n        const tokenKeys = this.getTokenKeys();\n\n        const accessTokens: AccessTokenEntity[] = [];\n        tokenKeys.accessToken.forEach((key) => {\n            if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {\n                return;\n            }\n\n            const accessToken = this.getAccessTokenCredential(key);\n            if (accessToken && this.credentialMatchesFilter(accessToken, filter)) {\n                accessTokens.push(accessToken);\n            }\n        });\n\n        return accessTokens;\n    }\n\n    /**\n     * Helper to retrieve the appropriate refresh token from cache\n     * @param clientId\n     * @param account\n     * @param familyRT\n     */\n    getRefreshToken(account: AccountInfo, familyRT: boolean, tokenKeys?: TokenKeys): RefreshTokenEntity | null {\n        this.commonLogger.trace(\"CacheManager - getRefreshToken called\");\n        const id = familyRT ? THE_FAMILY_ID : undefined;\n        const refreshTokenFilter: CredentialFilter = {\n            homeAccountId: account.homeAccountId,\n            environment: account.environment,\n            credentialType: CredentialType.REFRESH_TOKEN,\n            clientId: this.clientId,\n            familyId: id,\n        };\n\n        const refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;\n        const refreshTokens: RefreshTokenEntity[] = [];\n\n        refreshTokenKeys.forEach((key) => {\n            // Validate key\n            if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {\n                const refreshToken = this.getRefreshTokenCredential(key);\n                // Validate value\n                if (refreshToken && this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {\n                    refreshTokens.push(refreshToken);\n                }\n            }\n        });\n\n        const numRefreshTokens = refreshTokens.length;\n        if (numRefreshTokens < 1) {\n            this.commonLogger.info(\"CacheManager:getRefreshToken - No refresh token found.\");\n            return null;\n        }\n        // address the else case after remove functions address environment aliases\n\n        this.commonLogger.info(\"CacheManager:getRefreshToken - returning refresh token\");\n        return refreshTokens[0] as RefreshTokenEntity;\n    }\n\n    /**\n     * Validate the cache key against filter before retrieving and parsing cache value\n     * @param key\n     * @param filter\n     */\n    refreshTokenKeyMatchesFilter(inputKey: string, filter: CredentialFilter): boolean {\n        const key = inputKey.toLowerCase();\n        if (filter.familyId && key.indexOf(filter.familyId.toLowerCase()) === -1) {\n            return false;\n        }\n\n        // If familyId is used, clientId is not in the key\n        if (!filter.familyId && filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n            return false;\n        }\n\n        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Retrieve AppMetadataEntity from cache\n     */\n    readAppMetadataFromCache(environment: string): AppMetadataEntity | null {\n        const appMetadataFilter: AppMetadataFilter = {\n            environment,\n            clientId: this.clientId,\n        };\n\n        const appMetadata: AppMetadataCache = this.getAppMetadataFilteredBy(appMetadataFilter);\n        const appMetadataEntries: AppMetadataEntity[] = Object.keys(appMetadata).map((key) => appMetadata[key]);\n\n        const numAppMetadata = appMetadataEntries.length;\n        if (numAppMetadata < 1) {\n            return null;\n        } else if (numAppMetadata > 1) {\n            throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\n        }\n\n        return appMetadataEntries[0] as AppMetadataEntity;\n    }\n\n    /**\n     * Return the family_id value associated  with FOCI\n     * @param environment\n     * @param clientId\n     */\n    isAppMetadataFOCI(environment: string): boolean {\n        const appMetadata = this.readAppMetadataFromCache(environment);\n        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n    }\n\n    /**\n     * helper to match account ids\n     * @param value\n     * @param homeAccountId\n     */\n    private matchHomeAccountId(entity: AccountEntity | CredentialEntity, homeAccountId: string): boolean {\n        return !!((typeof entity.homeAccountId === \"string\") && (homeAccountId === entity.homeAccountId));\n    }\n\n    /**\n     * helper to match account ids\n     * @param entity \n     * @param localAccountId \n     * @returns \n     */\n    private matchLocalAccountId(entity: AccountEntity, localAccountId: string): boolean {\n        return !!((typeof entity.localAccountId === \"string\") && (localAccountId === entity.localAccountId));\n    }\n\n    /**\n     * helper to match usernames\n     * @param entity \n     * @param username \n     * @returns \n     */\n    private matchUsername(entity: AccountEntity, username: string): boolean {\n        return !!((typeof entity.username === \"string\") && (username.toLowerCase() === entity.username.toLowerCase()));\n    }\n\n    /**\n     * helper to match assertion\n     * @param value\n     * @param oboAssertion\n     */\n    private matchUserAssertionHash(entity: CredentialEntity, userAssertionHash: string): boolean {\n        return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);\n    }\n\n    /**\n     * helper to match environment\n     * @param value\n     * @param environment\n     */\n    private matchEnvironment(entity: AccountEntity | CredentialEntity | AppMetadataEntity, environment: string): boolean {\n        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * helper to match credential type\n     * @param entity\n     * @param credentialType\n     */\n    private matchCredentialType(entity: CredentialEntity, credentialType: string): boolean {\n        return (entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase());\n    }\n\n    /**\n     * helper to match client ids\n     * @param entity\n     * @param clientId\n     */\n    private matchClientId(entity: CredentialEntity | AppMetadataEntity, clientId: string): boolean {\n        return !!(entity.clientId && clientId === entity.clientId);\n    }\n\n    /**\n     * helper to match family ids\n     * @param entity\n     * @param familyId\n     */\n    private matchFamilyId(entity: CredentialEntity | AppMetadataEntity, familyId: string): boolean {\n        return !!(entity.familyId && familyId === entity.familyId);\n    }\n\n    /**\n     * helper to match realm\n     * @param entity\n     * @param realm\n     */\n    private matchRealm(entity: AccountEntity | CredentialEntity, realm: string): boolean {\n        return !!(entity.realm && realm === entity.realm);\n    }\n\n    /**\n     * helper to match nativeAccountId\n     * @param entity\n     * @param nativeAccountId\n     * @returns boolean indicating the match result\n     */\n    private matchNativeAccountId(entity: AccountEntity, nativeAccountId: string): boolean {\n        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\n    }\n\n    /**\n     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\n     * @param entity\n     * @param target\n     */\n    private matchTarget(entity: CredentialEntity, target: ScopeSet): boolean {\n        const isNotAccessTokenCredential = (entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);\n\n        if ( isNotAccessTokenCredential || !entity.target) {\n            return false;\n        }\n\n        const entityScopeSet: ScopeSet = ScopeSet.fromString(entity.target);\n\n        return entityScopeSet.containsScopeSet(target);\n    }\n\n    /**\n     * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\n     * @param entity\n     * @param tokenType\n     */\n    private matchTokenType(entity: CredentialEntity, tokenType: AuthenticationScheme): boolean {\n        return !!(entity.tokenType && entity.tokenType === tokenType);\n    }\n\n    /**\n     * Returns true if the credential's keyId matches the one in the request, false otherwise\n     * @param entity\n     * @param tokenType\n     */\n    private matchKeyId(entity: CredentialEntity, keyId: string): boolean {\n        return !!(entity.keyId && entity.keyId === keyId);\n    }\n\n    /**\n     * returns if a given cache entity is of the type appmetadata\n     * @param key\n     */\n    private isAppMetadata(key: string): boolean {\n        return key.indexOf(APP_METADATA) !== -1;\n    }\n\n    /**\n     * returns if a given cache entity is of the type authoritymetadata\n     * @param key\n     */\n    protected isAuthorityMetadata(key: string): boolean {\n        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n    }\n\n    /**\n     * returns cache key used for cloud instance metadata\n     */\n    generateAuthorityMetadataCacheKey(authority: string): string {\n        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;\n    }\n\n    /**\n     * Helper to convert serialized data to object\n     * @param obj\n     * @param json\n     */\n    static toObject<T>(obj: T, json: object): T {\n        for (const propertyName in json) {\n            obj[propertyName] = json[propertyName];\n        }\n        return obj;\n    }\n}\n\nexport class DefaultStorageClass extends CacheManager {\n    setAccount(): void {\n        const notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAccount(): AccountEntity {\n        const notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setIdTokenCredential(): void {\n        const notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getIdTokenCredential(): IdTokenEntity {\n        const notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setAccessTokenCredential(): void {\n        const notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAccessTokenCredential(): AccessTokenEntity {\n        const notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setRefreshTokenCredential(): void {\n        const notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getRefreshTokenCredential(): RefreshTokenEntity {\n        const notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setAppMetadata(): void {\n        const notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAppMetadata(): AppMetadataEntity {\n        const notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setServerTelemetry(): void {\n        const notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getServerTelemetry(): ServerTelemetryEntity {\n        const notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setAuthorityMetadata(): void {\n        const notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAuthorityMetadata(): AuthorityMetadataEntity | null {\n        const notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAuthorityMetadataKeys(): Array<string> {\n        const notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setThrottlingCache(): void {\n        const notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getThrottlingCache(): ThrottlingEntity {\n        const notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    removeItem(): boolean {\n        const notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    containsKey(): boolean {\n        const notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getKeys(): string[] {\n        const notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAccountKeys(): string[] {\n        const notImplErr = \"Storage interface - getAccountKeys() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getTokenKeys(): TokenKeys {\n        const notImplErr = \"Storage interface - getTokenKeys() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    async clear(): Promise<void> {\n        const notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    updateCredentialCacheKey(): string {\n        const notImplErr = \"Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}