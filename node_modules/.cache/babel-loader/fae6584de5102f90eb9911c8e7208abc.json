{"ast":null,"code":"/*! @azure/msal-common v13.0.0 2023-05-01 */\n'use strict';\n\nimport { __extends, __awaiter, __generator, __assign, __spreadArrays } from '../_virtual/_tslib.js';\nimport { BaseClient } from './BaseClient.js';\nimport { RequestParameterBuilder } from '../request/RequestParameterBuilder.js';\nimport { Separators, AADServerParamKeys, AuthenticationScheme, GrantType, PromptValue, HeaderNames } from '../utils/Constants.js';\nimport { ResponseHandler } from '../response/ResponseHandler.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { UrlString } from '../url/UrlString.js';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.js';\nimport { TimeUtils } from '../utils/TimeUtils.js';\nimport { buildClientInfo, buildClientInfoFromHomeAccountId } from '../account/ClientInfo.js';\nimport { CcsCredentialType } from '../account/CcsCredential.js';\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.js';\nimport { RequestValidator } from '../request/RequestValidator.js';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Oauth2.0 Authorization Code client\r\n */\n\nvar AuthorizationCodeClient =\n/** @class */\nfunction (_super) {\n  __extends(AuthorizationCodeClient, _super);\n\n  function AuthorizationCodeClient(configuration, performanceClient) {\n    var _this = _super.call(this, configuration, performanceClient) || this; // Flag to indicate if client is for hybrid spa auth code redemption\n\n\n    _this.includeRedirectUri = true;\n    return _this;\n  }\n  /**\r\n   * Creates the URL of the authorization request letting the user input credentials and consent to the\r\n   * application. The URL target the /authorize endpoint of the authority configured in the\r\n   * application object.\r\n   *\r\n   * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\r\n   * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\r\n   * acquireToken(AuthorizationCodeRequest)\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.getAuthCodeUrl = function (request) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var queryString;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.GetAuthCodeUrl, request.correlationId);\n            (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.AuthClientCreateQueryString, request.correlationId);\n            return [4\n            /*yield*/\n            , this.createAuthCodeUrlQueryString(request)];\n\n          case 1:\n            queryString = _c.sent();\n            return [2\n            /*return*/\n            , UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString)];\n        }\n      });\n    });\n  };\n  /**\r\n   * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\r\n   * authorization_code_grant\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.acquireToken = function (request, authCodePayload) {\n    var _a, _b, _c, _d, _e, _f;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var atsMeasurement, reqTimestamp, response, requestId, httpVerAuthority, responseHandler;\n\n      var _this = this;\n\n      return __generator(this, function (_g) {\n        switch (_g.label) {\n          case 0:\n            if (!request || !request.code) {\n              throw ClientAuthError.createTokenRequestCannotBeMadeError();\n            }\n\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);\n            atsMeasurement = (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.startMeasurement(\"AuthCodeClientAcquireToken\", request.correlationId);\n            this.logger.info(\"in acquireToken call in auth-code client\");\n            reqTimestamp = TimeUtils.nowSeconds();\n            (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);\n            return [4\n            /*yield*/\n            , this.executeTokenRequest(this.authority, request)];\n\n          case 1:\n            response = _g.sent();\n            requestId = (_d = response.headers) === null || _d === void 0 ? void 0 : _d[HeaderNames.X_MS_REQUEST_ID];\n            httpVerAuthority = (_e = response.headers) === null || _e === void 0 ? void 0 : _e[HeaderNames.X_MS_HTTP_VERSION];\n\n            if (httpVerAuthority) {\n              atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.addStaticFields({\n                httpVerAuthority: httpVerAuthority\n              });\n            }\n\n            responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient); // Validate response. This function throws a server error if an error is returned by the server.\n\n            responseHandler.validateTokenResponse(response.body);\n            (_f = this.performanceClient) === null || _f === void 0 ? void 0 : _f.setPreQueueTime(PerformanceEvents.HandleServerTokenResponse, request.correlationId);\n            return [2\n            /*return*/\n            , responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, authCodePayload, undefined, undefined, undefined, requestId).then(function (result) {\n              atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({\n                success: true\n              });\n              return result;\n            }).catch(function (error) {\n              _this.logger.verbose(\"Error in fetching token in ACC\", request.correlationId);\n\n              atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({\n                errorCode: error.errorCode,\n                subErrorCode: error.subError,\n                success: false\n              });\n              throw error;\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   * Handles the hash fragment response from public client code request. Returns a code response used by\r\n   * the client to exchange for a token in acquireToken.\r\n   * @param hashFragment\r\n   */\n\n\n  AuthorizationCodeClient.prototype.handleFragmentResponse = function (hashFragment, cachedState) {\n    // Handle responses.\n    var responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null); // Deserialize hash fragment response parameters.\n\n    var hashUrlString = new UrlString(hashFragment); // Deserialize hash fragment response parameters.\n\n    var serverParams = UrlString.getDeserializedHash(hashUrlString.getHash()); // Get code response\n\n    responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils); // throw when there is no auth code in the response\n\n    if (!serverParams.code) {\n      throw ClientAuthError.createNoAuthCodeInServerResponseError();\n    }\n\n    return __assign(__assign({}, serverParams), {\n      // Code param is optional in ServerAuthorizationCodeResponse but required in AuthorizationCodePaylod\n      code: serverParams.code\n    });\n  };\n  /**\r\n   * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n   * Default behaviour is to redirect the user to `window.location.href`.\r\n   * @param authorityUri\r\n   */\n\n\n  AuthorizationCodeClient.prototype.getLogoutUri = function (logoutRequest) {\n    // Throw error if logoutRequest is null/undefined\n    if (!logoutRequest) {\n      throw ClientConfigurationError.createEmptyLogoutRequestError();\n    }\n\n    var queryString = this.createLogoutUrlQueryString(logoutRequest); // Construct logout URI\n\n    return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);\n  };\n  /**\r\n   * Executes POST request to token endpoint\r\n   * @param authority\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.executeTokenRequest = function (authority, request) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var queryParametersString, endpoint, requestBody, ccsCredential, clientInfo, headers, thumbprint;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);\n            (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);\n            queryParametersString = this.createTokenQueryParameters(request);\n            endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\n            return [4\n            /*yield*/\n            , this.createTokenRequestBody(request)];\n\n          case 1:\n            requestBody = _c.sent();\n            ccsCredential = undefined;\n\n            if (request.clientInfo) {\n              try {\n                clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\n                ccsCredential = {\n                  credential: \"\" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,\n                  type: CcsCredentialType.HOME_ACCOUNT_ID\n                };\n              } catch (e) {\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n              }\n            }\n\n            headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);\n            thumbprint = {\n              clientId: this.config.authOptions.clientId,\n              authority: authority.canonicalAuthority,\n              scopes: request.scopes,\n              claims: request.claims,\n              authenticationScheme: request.authenticationScheme,\n              resourceRequestMethod: request.resourceRequestMethod,\n              resourceRequestUri: request.resourceRequestUri,\n              shrClaims: request.shrClaims,\n              sshKid: request.sshKid\n            };\n            return [2\n            /*return*/\n            , this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Generates a map for all the params to be sent to the service\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.createTokenRequestBody = function (request) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var parameterBuilder, clientAssertion, popTokenGenerator, reqCnfData, correlationId, ccsCred, clientInfo, clientInfo;\n\n      var _c;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);\n            parameterBuilder = new RequestParameterBuilder();\n            parameterBuilder.addClientId(this.config.authOptions.clientId);\n            /*\r\n             * For hybrid spa flow, there will be a code but no verifier\r\n             * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI\r\n             */\n\n            if (!this.includeRedirectUri) {\n              // Just validate\n              RequestValidator.validateRedirectUri(request.redirectUri);\n            } else {\n              // Validate and include redirect uri\n              parameterBuilder.addRedirectUri(request.redirectUri);\n            } // Add scope array, parameter builder will add default scopes and dedupe\n\n\n            parameterBuilder.addScopes(request.scopes); // add code: user set, not validated\n\n            parameterBuilder.addAuthorizationCode(request.code); // Add library metadata\n\n            parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n            parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\n            parameterBuilder.addThrottling();\n\n            if (this.serverTelemetryManager) {\n              parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n            } // add code_verifier if passed\n\n\n            if (request.codeVerifier) {\n              parameterBuilder.addCodeVerifier(request.codeVerifier);\n            }\n\n            if (this.config.clientCredentials.clientSecret) {\n              parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\n            }\n\n            if (this.config.clientCredentials.clientAssertion) {\n              clientAssertion = this.config.clientCredentials.clientAssertion;\n              parameterBuilder.addClientAssertion(clientAssertion.assertion);\n              parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\n            }\n\n            parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\n            parameterBuilder.addClientInfo();\n            if (!(request.authenticationScheme === AuthenticationScheme.POP)) return [3\n            /*break*/\n            , 2];\n            popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);\n            (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);\n            return [4\n            /*yield*/\n            , popTokenGenerator.generateCnf(request)];\n\n          case 1:\n            reqCnfData = _d.sent(); // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\n\n            parameterBuilder.addPopToken(reqCnfData.reqCnfString);\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            if (request.authenticationScheme === AuthenticationScheme.SSH) {\n              if (request.sshJwk) {\n                parameterBuilder.addSshJwk(request.sshJwk);\n              } else {\n                throw ClientConfigurationError.createMissingSshJwkError();\n              }\n            }\n\n            _d.label = 3;\n\n          case 3:\n            correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n            parameterBuilder.addCorrelationId(correlationId);\n\n            if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n              parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n            }\n\n            ccsCred = undefined;\n\n            if (request.clientInfo) {\n              try {\n                clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\n                ccsCred = {\n                  credential: \"\" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,\n                  type: CcsCredentialType.HOME_ACCOUNT_ID\n                };\n              } catch (e) {\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n              }\n            } else {\n              ccsCred = request.ccsCredential;\n            } // Adds these as parameters in the request instead of headers to prevent CORS preflight request\n\n\n            if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\n              switch (ccsCred.type) {\n                case CcsCredentialType.HOME_ACCOUNT_ID:\n                  try {\n                    clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);\n                    parameterBuilder.addCcsOid(clientInfo);\n                  } catch (e) {\n                    this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n                  }\n\n                  break;\n\n                case CcsCredentialType.UPN:\n                  parameterBuilder.addCcsUpn(ccsCred.credential);\n                  break;\n              }\n            }\n\n            if (request.tokenBodyParameters) {\n              parameterBuilder.addExtraQueryParameters(request.tokenBodyParameters);\n            } // Add hybrid spa parameters if not already provided\n\n\n            if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[AADServerParamKeys.RETURN_SPA_CODE])) {\n              parameterBuilder.addExtraQueryParameters((_c = {}, _c[AADServerParamKeys.RETURN_SPA_CODE] = \"1\", _c));\n            }\n\n            return [2\n            /*return*/\n            , parameterBuilder.createQueryString()];\n        }\n      });\n    });\n  };\n  /**\r\n   * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.createAuthCodeUrlQueryString = function (request) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var parameterBuilder, requestScopes, correlationId, accountSid, accountLoginHintClaim, clientInfo, clientInfo, clientInfo, popTokenGenerator, reqCnfData;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientCreateQueryString, request.correlationId);\n            parameterBuilder = new RequestParameterBuilder();\n            parameterBuilder.addClientId(this.config.authOptions.clientId);\n            requestScopes = __spreadArrays(request.scopes || [], request.extraScopesToConsent || []);\n            parameterBuilder.addScopes(requestScopes); // validate the redirectUri (to be a non null value)\n\n            parameterBuilder.addRedirectUri(request.redirectUri);\n            correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n            parameterBuilder.addCorrelationId(correlationId); // add response_mode. If not passed in it defaults to query.\n\n            parameterBuilder.addResponseMode(request.responseMode); // add response_type = code\n\n            parameterBuilder.addResponseTypeCode(); // add library info parameters\n\n            parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n            parameterBuilder.addApplicationTelemetry(this.config.telemetry.application); // add client_info=1\n\n            parameterBuilder.addClientInfo();\n\n            if (request.codeChallenge && request.codeChallengeMethod) {\n              parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);\n            }\n\n            if (request.prompt) {\n              parameterBuilder.addPrompt(request.prompt);\n            }\n\n            if (request.domainHint) {\n              parameterBuilder.addDomainHint(request.domainHint);\n            } // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object\n\n\n            if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\n              // AAD will throw if prompt=select_account is passed with an account hint\n              if (request.sid && request.prompt === PromptValue.NONE) {\n                // SessionID is only used in silent calls\n                this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\");\n                parameterBuilder.addSid(request.sid);\n              } else if (request.account) {\n                accountSid = this.extractAccountSid(request.account);\n                accountLoginHintClaim = this.extractLoginHint(request.account); // If login_hint claim is present, use it over sid/username\n\n                if (accountLoginHintClaim) {\n                  this.logger.verbose(\"createAuthCodeUrlQueryString: login_hint claim present on account\");\n                  parameterBuilder.addLoginHint(accountLoginHintClaim);\n\n                  try {\n                    clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n                    parameterBuilder.addCcsOid(clientInfo);\n                  } catch (e) {\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n                  }\n                } else if (accountSid && request.prompt === PromptValue.NONE) {\n                  /*\r\n                   * If account and loginHint are provided, we will check account first for sid before adding loginHint\r\n                   * SessionId is only used in silent calls\r\n                   */\n                  this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\");\n                  parameterBuilder.addSid(accountSid);\n\n                  try {\n                    clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n                    parameterBuilder.addCcsOid(clientInfo);\n                  } catch (e) {\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n                  }\n                } else if (request.loginHint) {\n                  this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from request\");\n                  parameterBuilder.addLoginHint(request.loginHint);\n                  parameterBuilder.addCcsUpn(request.loginHint);\n                } else if (request.account.username) {\n                  // Fallback to account username if provided\n                  this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from account\");\n                  parameterBuilder.addLoginHint(request.account.username);\n\n                  try {\n                    clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n                    parameterBuilder.addCcsOid(clientInfo);\n                  } catch (e) {\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n                  }\n                }\n              } else if (request.loginHint) {\n                this.logger.verbose(\"createAuthCodeUrlQueryString: No account, adding login_hint from request\");\n                parameterBuilder.addLoginHint(request.loginHint);\n                parameterBuilder.addCcsUpn(request.loginHint);\n              }\n            } else {\n              this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\");\n            }\n\n            if (request.nonce) {\n              parameterBuilder.addNonce(request.nonce);\n            }\n\n            if (request.state) {\n              parameterBuilder.addState(request.state);\n            }\n\n            if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n              parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n            }\n\n            if (request.extraQueryParameters) {\n              parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n            }\n\n            if (!request.nativeBroker) return [3\n            /*break*/\n            , 2]; // signal ests that this is a WAM call\n\n            parameterBuilder.addNativeBroker();\n            if (!(request.authenticationScheme === AuthenticationScheme.POP)) return [3\n            /*break*/\n            , 2];\n            popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);\n            return [4\n            /*yield*/\n            , popTokenGenerator.generateCnf(request)];\n\n          case 1:\n            reqCnfData = _b.sent();\n            parameterBuilder.addPopToken(reqCnfData.reqCnfHash);\n            _b.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            , parameterBuilder.createQueryString()];\n        }\n      });\n    });\n  };\n  /**\r\n   * This API validates the `EndSessionRequest` and creates a URL\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.createLogoutUrlQueryString = function (request) {\n    var parameterBuilder = new RequestParameterBuilder();\n\n    if (request.postLogoutRedirectUri) {\n      parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);\n    }\n\n    if (request.correlationId) {\n      parameterBuilder.addCorrelationId(request.correlationId);\n    }\n\n    if (request.idTokenHint) {\n      parameterBuilder.addIdTokenHint(request.idTokenHint);\n    }\n\n    if (request.state) {\n      parameterBuilder.addState(request.state);\n    }\n\n    if (request.logoutHint) {\n      parameterBuilder.addLogoutHint(request.logoutHint);\n    }\n\n    if (request.extraQueryParameters) {\n      parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n    }\n\n    return parameterBuilder.createQueryString();\n  };\n  /**\r\n   * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\r\n   * @param account\r\n   */\n\n\n  AuthorizationCodeClient.prototype.extractAccountSid = function (account) {\n    var _a;\n\n    return ((_a = account.idTokenClaims) === null || _a === void 0 ? void 0 : _a.sid) || null;\n  };\n\n  AuthorizationCodeClient.prototype.extractLoginHint = function (account) {\n    var _a;\n\n    return ((_a = account.idTokenClaims) === null || _a === void 0 ? void 0 : _a.login_hint) || null;\n  };\n\n  return AuthorizationCodeClient;\n}(BaseClient);\n\nexport { AuthorizationCodeClient };","map":{"version":3,"mappings":"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","names":["__extends","AuthorizationCodeClient","configuration","performanceClient","_super","_this","getAuthCodeUrl","request","_a","addQueueMeasurement","PerformanceEvents","GetAuthCodeUrl","correlationId","_b","setPreQueueTime","AuthClientCreateQueryString","createAuthCodeUrlQueryString","queryString","_c","UrlString","appendQueryString","authority","authorizationEndpoint","authCodePayload","code","ClientAuthError","createTokenRequestCannotBeMadeError","AuthClientAcquireToken","atsMeasurement","logger","info","reqTimestamp","TimeUtils","nowSeconds","AuthClientExecuteTokenRequest","executeTokenRequest","response","_g","requestId","headers","_d","HeaderNames","X_MS_REQUEST_ID","httpVerAuthority","_e","X_MS_HTTP_VERSION","addStaticFields","responseHandler","ResponseHandler","config","authOptions","clientId","cacheManager","cryptoUtils","serializableCache","persistencePlugin","validateTokenResponse","body","_f","HandleServerTokenResponse","handleServerTokenResponse","undefined","then","result","endMeasurement","success","catch","error","verbose","errorCode","subErrorCode","subError","hashFragment","cachedState","hashUrlString","serverParams","getDeserializedHash","getHash","validateServerAuthorizationCodeResponse","createNoAuthCodeInServerResponseError","getLogoutUri","logoutRequest","ClientConfigurationError","createEmptyLogoutRequestError","createLogoutUrlQueryString","endSessionEndpoint","AuthClientCreateTokenRequestBody","queryParametersString","createTokenQueryParameters","endpoint","tokenEndpoint","createTokenRequestBody","requestBody","ccsCredential","clientInfo","buildClientInfo","credential","uid","Separators","CLIENT_INFO_SEPARATOR","utid","type","CcsCredentialType","HOME_ACCOUNT_ID","e","createTokenRequestHeaders","thumbprint","canonicalAuthority","scopes","claims","authenticationScheme","resourceRequestMethod","resourceRequestUri","shrClaims","sshKid","executePostToTokenEndpoint","parameterBuilder","RequestParameterBuilder","addClientId","includeRedirectUri","RequestValidator","validateRedirectUri","redirectUri","addRedirectUri","addScopes","addAuthorizationCode","addLibraryInfo","libraryInfo","addApplicationTelemetry","telemetry","application","addThrottling","serverTelemetryManager","addServerTelemetry","codeVerifier","addCodeVerifier","clientCredentials","clientSecret","addClientSecret","clientAssertion","addClientAssertion","assertion","addClientAssertionType","assertionType","addGrantType","GrantType","AUTHORIZATION_CODE_GRANT","addClientInfo","AuthenticationScheme","POP","popTokenGenerator","PopTokenGenerator","PopTokenGenerateCnf","generateCnf","reqCnfData","addPopToken","reqCnfString","SSH","sshJwk","addSshJwk","createMissingSshJwkError","cryptoInterface","createNewGuid","addCorrelationId","StringUtils","isEmptyObj","clientCapabilities","length","addClaims","ccsCred","systemOptions","preventCorsPreflight","buildClientInfoFromHomeAccountId","addCcsOid","UPN","addCcsUpn","tokenBodyParameters","addExtraQueryParameters","enableSpaAuthorizationCode","AADServerParamKeys","RETURN_SPA_CODE","createQueryString","requestScopes","__spreadArrays","extraScopesToConsent","addResponseMode","responseMode","addResponseTypeCode","codeChallenge","codeChallengeMethod","addCodeChallengeParams","prompt","addPrompt","domainHint","addDomainHint","PromptValue","SELECT_ACCOUNT","sid","NONE","addSid","account","accountSid","extractAccountSid","accountLoginHintClaim","extractLoginHint","addLoginHint","homeAccountId","loginHint","username","nonce","addNonce","state","addState","isEmpty","extraQueryParameters","nativeBroker","addNativeBroker","reqCnfHash","postLogoutRedirectUri","addPostLogoutRedirectUri","idTokenHint","addIdTokenHint","logoutHint","addLogoutHint","idTokenClaims","login_hint","BaseClient"],"sources":["/Users/edwardlee/Downloads/msal-react-demo/node_modules/@azure/msal-common/src/client/AuthorizationCodeClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { BaseClient } from \"./BaseClient\";\nimport { CommonAuthorizationUrlRequest } from \"../request/CommonAuthorizationUrlRequest\";\nimport { CommonAuthorizationCodeRequest } from \"../request/CommonAuthorizationCodeRequest\";\nimport { Authority } from \"../authority/Authority\";\nimport { RequestParameterBuilder } from \"../request/RequestParameterBuilder\";\nimport { GrantType, AuthenticationScheme, PromptValue, Separators, AADServerParamKeys, HeaderNames } from \"../utils/Constants\";\nimport { ClientConfiguration } from \"../config/ClientConfiguration\";\nimport { ServerAuthorizationTokenResponse } from \"../response/ServerAuthorizationTokenResponse\";\nimport { NetworkResponse } from \"../network/NetworkManager\";\nimport { ResponseHandler } from \"../response/ResponseHandler\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\nimport { StringUtils } from \"../utils/StringUtils\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\nimport { UrlString } from \"../url/UrlString\";\nimport { ServerAuthorizationCodeResponse } from \"../response/ServerAuthorizationCodeResponse\";\nimport { CommonEndSessionRequest } from \"../request/CommonEndSessionRequest\";\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator\";\nimport { RequestThumbprint } from \"../network/RequestThumbprint\";\nimport { AuthorizationCodePayload } from \"../response/AuthorizationCodePayload\";\nimport { TimeUtils } from \"../utils/TimeUtils\";\nimport { AccountInfo } from \"../account/AccountInfo\";\nimport { buildClientInfoFromHomeAccountId, buildClientInfo } from \"../account/ClientInfo\";\nimport { CcsCredentialType, CcsCredential } from \"../account/CcsCredential\";\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\nimport { RequestValidator } from \"../request/RequestValidator\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent\";\n\n/**\n * Oauth2.0 Authorization Code client\n */\nexport class AuthorizationCodeClient extends BaseClient {\n    // Flag to indicate if client is for hybrid spa auth code redemption\n    protected includeRedirectUri: boolean = true;\n\n    constructor(configuration: ClientConfiguration, performanceClient?: IPerformanceClient) {\n        super(configuration, performanceClient);\n    }\n\n    /**\n     * Creates the URL of the authorization request letting the user input credentials and consent to the\n     * application. The URL target the /authorize endpoint of the authority configured in the\n     * application object.\n     *\n     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\n     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\n     * acquireToken(AuthorizationCodeRequest)\n     * @param request\n     */\n    async getAuthCodeUrl(request: CommonAuthorizationUrlRequest): Promise<string> {\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.GetAuthCodeUrl, request.correlationId);\n\n        this.performanceClient?.setPreQueueTime(PerformanceEvents.AuthClientCreateQueryString, request.correlationId);\n        const queryString = await this.createAuthCodeUrlQueryString(request);\n\n        return UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString);\n    }\n\n    /**\n     * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\n     * authorization_code_grant\n     * @param request\n     */\n    async acquireToken(request: CommonAuthorizationCodeRequest, authCodePayload?: AuthorizationCodePayload): Promise<AuthenticationResult> {\n        if (!request || !request.code) {\n            throw ClientAuthError.createTokenRequestCannotBeMadeError();\n        }\n\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);\n        \n        // @ts-ignore\n        const atsMeasurement = this.performanceClient?.startMeasurement(\"AuthCodeClientAcquireToken\", request.correlationId);\n        this.logger.info(\"in acquireToken call in auth-code client\");\n\n        const reqTimestamp = TimeUtils.nowSeconds();\n        this.performanceClient?.setPreQueueTime(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);\n        const response = await this.executeTokenRequest(this.authority, request);\n\n        // Retrieve requestId from response headers\n        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];\n        const httpVerAuthority = response.headers?.[HeaderNames.X_MS_HTTP_VERSION];\n        if(httpVerAuthority)\n        {\n            atsMeasurement?.addStaticFields({\n                httpVerAuthority\n            });\n        }\n        const responseHandler = new ResponseHandler(\n            this.config.authOptions.clientId,\n            this.cacheManager,\n            this.cryptoUtils,\n            this.logger,\n            this.config.serializableCache,\n            this.config.persistencePlugin,\n            this.performanceClient\n        );\n\n        // Validate response. This function throws a server error if an error is returned by the server.\n        responseHandler.validateTokenResponse(response.body);\n\n        this.performanceClient?.setPreQueueTime(PerformanceEvents.HandleServerTokenResponse, request.correlationId);\n        return responseHandler.handleServerTokenResponse(\n            response.body,\n            this.authority,\n            reqTimestamp,\n            request,\n            authCodePayload,\n            undefined,\n            undefined,\n            undefined,\n            requestId\n        ).then((result: AuthenticationResult) => {\n            atsMeasurement?.endMeasurement({\n                success: true\n            });\n            return result;\n        })\n            .catch((error) => {\n                this.logger.verbose(\"Error in fetching token in ACC\", request.correlationId);\n                atsMeasurement?.endMeasurement({\n                    errorCode: error.errorCode,\n                    subErrorCode: error.subError,\n                    success: false\n                });\n                throw error;\n            });\n    }\n\n    /**\n     * Handles the hash fragment response from public client code request. Returns a code response used by\n     * the client to exchange for a token in acquireToken.\n     * @param hashFragment\n     */\n    handleFragmentResponse(hashFragment: string, cachedState: string): AuthorizationCodePayload {\n        // Handle responses.\n        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null);\n\n        // Deserialize hash fragment response parameters.\n        const hashUrlString = new UrlString(hashFragment);\n        // Deserialize hash fragment response parameters.\n        const serverParams: ServerAuthorizationCodeResponse = UrlString.getDeserializedHash(hashUrlString.getHash());\n\n        // Get code response\n        responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils);\n\n        // throw when there is no auth code in the response\n        if (!serverParams.code) {\n            throw ClientAuthError.createNoAuthCodeInServerResponseError();\n        }\n        return {\n            ...serverParams,\n            // Code param is optional in ServerAuthorizationCodeResponse but required in AuthorizationCodePaylod\n            code: serverParams.code\n        };\n    }\n\n    /**\n     * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\n     * Default behaviour is to redirect the user to `window.location.href`.\n     * @param authorityUri\n     */\n    getLogoutUri(logoutRequest: CommonEndSessionRequest): string {\n        // Throw error if logoutRequest is null/undefined\n        if (!logoutRequest) {\n            throw ClientConfigurationError.createEmptyLogoutRequestError();\n        }\n        const queryString = this.createLogoutUrlQueryString(logoutRequest);\n\n        // Construct logout URI\n        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);\n    }\n\n    /**\n     * Executes POST request to token endpoint\n     * @param authority\n     * @param request\n     */\n    private async executeTokenRequest(authority: Authority, request: CommonAuthorizationCodeRequest): Promise<NetworkResponse<ServerAuthorizationTokenResponse>> {\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);\n        this.performanceClient?.setPreQueueTime(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);\n        \n        const queryParametersString = this.createTokenQueryParameters(request);\n        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\n        \n        const requestBody = await this.createTokenRequestBody(request);\n        \n        let ccsCredential: CcsCredential | undefined = undefined;\n        if (request.clientInfo) {\n            try {\n                const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\n                ccsCredential = {\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n                    type: CcsCredentialType.HOME_ACCOUNT_ID\n                };\n            } catch (e) {\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n            }\n        }\n        const headers: Record<string, string> = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);\n\n        const thumbprint: RequestThumbprint = {\n            clientId: this.config.authOptions.clientId,\n            authority: authority.canonicalAuthority,\n            scopes: request.scopes,\n            claims: request.claims,\n            authenticationScheme: request.authenticationScheme,\n            resourceRequestMethod: request.resourceRequestMethod,\n            resourceRequestUri: request.resourceRequestUri,\n            shrClaims: request.shrClaims,\n            sshKid: request.sshKid\n        };\n\n        return this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint);\n    }\n\n    /**\n     * Generates a map for all the params to be sent to the service\n     * @param request\n     */\n    private async createTokenRequestBody(request: CommonAuthorizationCodeRequest): Promise<string> {\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);\n\n        const parameterBuilder = new RequestParameterBuilder();\n\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\n\n        /*\n         * For hybrid spa flow, there will be a code but no verifier\n         * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI\n         */\n        if (!this.includeRedirectUri) {\n            // Just validate\n            RequestValidator.validateRedirectUri(request.redirectUri);\n        } else {\n            // Validate and include redirect uri\n            parameterBuilder.addRedirectUri(request.redirectUri);\n        }\n\n        // Add scope array, parameter builder will add default scopes and dedupe\n        parameterBuilder.addScopes(request.scopes);\n\n        // add code: user set, not validated\n        parameterBuilder.addAuthorizationCode(request.code);\n\n        // Add library metadata\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\n        parameterBuilder.addThrottling();\n\n        if (this.serverTelemetryManager) {\n            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n        }\n\n        // add code_verifier if passed\n        if (request.codeVerifier) {\n            parameterBuilder.addCodeVerifier(request.codeVerifier);\n        }\n\n        if (this.config.clientCredentials.clientSecret) {\n            parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\n        }\n\n        if (this.config.clientCredentials.clientAssertion) {\n            const clientAssertion = this.config.clientCredentials.clientAssertion;\n            parameterBuilder.addClientAssertion(clientAssertion.assertion);\n            parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\n        }\n\n        parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\n        parameterBuilder.addClientInfo();\n\n        if (request.authenticationScheme === AuthenticationScheme.POP) {\n            const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);\n\n            this.performanceClient?.setPreQueueTime(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);\n            const reqCnfData = await popTokenGenerator.generateCnf(request);\n            // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\n            parameterBuilder.addPopToken(reqCnfData.reqCnfString);\n        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {\n            if (request.sshJwk) {\n                parameterBuilder.addSshJwk(request.sshJwk);\n            } else {\n                throw ClientConfigurationError.createMissingSshJwkError();\n            }\n        }\n\n        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n        parameterBuilder.addCorrelationId(correlationId);\n\n        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n        }\n\n        let ccsCred: CcsCredential | undefined = undefined;\n        if (request.clientInfo) {\n            try {\n                const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\n                ccsCred = {\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n                    type: CcsCredentialType.HOME_ACCOUNT_ID\n                };\n            } catch (e) {\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n            }\n        } else {\n            ccsCred = request.ccsCredential;\n        }\n\n        // Adds these as parameters in the request instead of headers to prevent CORS preflight request\n        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\n            switch (ccsCred.type) {\n                case CcsCredentialType.HOME_ACCOUNT_ID:\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n                    }\n                    break;\n                case CcsCredentialType.UPN:\n                    parameterBuilder.addCcsUpn(ccsCred.credential);\n                    break;\n            }\n        }\n\n        if (request.tokenBodyParameters) {\n            parameterBuilder.addExtraQueryParameters(request.tokenBodyParameters);\n        }\n\n        // Add hybrid spa parameters if not already provided\n        if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[AADServerParamKeys.RETURN_SPA_CODE])) {\n            parameterBuilder.addExtraQueryParameters({\n                [AADServerParamKeys.RETURN_SPA_CODE]: \"1\"\n            });\n        }\n\n        return parameterBuilder.createQueryString();\n    }\n\n    /**\n     * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\n     * @param request\n     */\n    private async createAuthCodeUrlQueryString(request: CommonAuthorizationUrlRequest): Promise<string> {\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateQueryString, request.correlationId);\n\n        const parameterBuilder = new RequestParameterBuilder();\n\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\n\n        const requestScopes = [...request.scopes || [], ...request.extraScopesToConsent || []];\n        parameterBuilder.addScopes(requestScopes);\n\n        // validate the redirectUri (to be a non null value)\n        parameterBuilder.addRedirectUri(request.redirectUri);\n\n        // generate the correlationId if not set by the user and add\n        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n        parameterBuilder.addCorrelationId(correlationId);\n\n        // add response_mode. If not passed in it defaults to query.\n        parameterBuilder.addResponseMode(request.responseMode);\n\n        // add response_type = code\n        parameterBuilder.addResponseTypeCode();\n\n        // add library info parameters\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\n\n        // add client_info=1\n        parameterBuilder.addClientInfo();\n\n        if (request.codeChallenge && request.codeChallengeMethod) {\n            parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);\n        }\n\n        if (request.prompt) {\n            parameterBuilder.addPrompt(request.prompt);\n        }\n\n        if (request.domainHint) {\n            parameterBuilder.addDomainHint(request.domainHint);\n        }\n\n        // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object\n        if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\n            // AAD will throw if prompt=select_account is passed with an account hint\n            if (request.sid && request.prompt === PromptValue.NONE) {\n                // SessionID is only used in silent calls\n                this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\");\n                parameterBuilder.addSid(request.sid);\n            } else if (request.account) {\n                const accountSid = this.extractAccountSid(request.account);\n                const accountLoginHintClaim = this.extractLoginHint(request.account);\n                // If login_hint claim is present, use it over sid/username\n                if (accountLoginHintClaim) {\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: login_hint claim present on account\");\n                    parameterBuilder.addLoginHint(accountLoginHintClaim);\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n                    }\n                } else if (accountSid && request.prompt === PromptValue.NONE) {\n                    /*\n                     * If account and loginHint are provided, we will check account first for sid before adding loginHint\n                     * SessionId is only used in silent calls\n                     */\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\");\n                    parameterBuilder.addSid(accountSid);\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n                    }\n                } else if (request.loginHint) {\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from request\");\n                    parameterBuilder.addLoginHint(request.loginHint);\n                    parameterBuilder.addCcsUpn(request.loginHint);\n                } else if (request.account.username) {\n                    // Fallback to account username if provided\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from account\");\n                    parameterBuilder.addLoginHint(request.account.username);\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n                    }\n                }\n            } else if (request.loginHint) {\n                this.logger.verbose(\"createAuthCodeUrlQueryString: No account, adding login_hint from request\");\n                parameterBuilder.addLoginHint(request.loginHint);\n                parameterBuilder.addCcsUpn(request.loginHint);\n            }\n        } else {\n            this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\");\n        }\n\n        if (request.nonce) {\n            parameterBuilder.addNonce(request.nonce);\n        }\n\n        if (request.state) {\n            parameterBuilder.addState(request.state);\n        }\n\n        if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n        }\n\n        if (request.extraQueryParameters) {\n            parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n        }\n\n        if (request.nativeBroker) {\n            // signal ests that this is a WAM call\n            parameterBuilder.addNativeBroker();\n\n            // pass the req_cnf for POP\n            if (request.authenticationScheme === AuthenticationScheme.POP) {\n                const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);\n                // to reduce the URL length, it is recommended to send the hash of the req_cnf instead of the whole string\n                const reqCnfData = await popTokenGenerator.generateCnf(request);\n                parameterBuilder.addPopToken(reqCnfData.reqCnfHash);\n            }\n        }\n\n        return parameterBuilder.createQueryString();\n    }\n\n    /**\n     * This API validates the `EndSessionRequest` and creates a URL\n     * @param request\n     */\n    private createLogoutUrlQueryString(request: CommonEndSessionRequest): string {\n        const parameterBuilder = new RequestParameterBuilder();\n\n        if (request.postLogoutRedirectUri) {\n            parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);\n        }\n\n        if (request.correlationId) {\n            parameterBuilder.addCorrelationId(request.correlationId);\n        }\n\n        if (request.idTokenHint) {\n            parameterBuilder.addIdTokenHint(request.idTokenHint);\n        }\n\n        if (request.state) {\n            parameterBuilder.addState(request.state);\n        }\n\n        if (request.logoutHint) {\n            parameterBuilder.addLogoutHint(request.logoutHint);\n        }\n\n        if (request.extraQueryParameters) {\n            parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n        }\n\n        return parameterBuilder.createQueryString();\n    }\n\n    /**\n     * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\n     * @param account\n     */\n    private extractAccountSid(account: AccountInfo): string | null {\n        return account.idTokenClaims?.sid || null;\n    }\n\n    private extractLoginHint(account: AccountInfo): string | null {\n        return account.idTokenClaims?.login_hint || null;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}